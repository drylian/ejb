// Combined source for @kirejs/analytical

// --- From: packages/analytical/src/compiler.ts ---
import type { Node, KireContext } from 'kire';
import type { Kire } from 'kire';
import './types'; // This is for module augmentation

export class AnalyticalCompiler {
  private preBuffer: string[] = [];
  private resBuffer: string[] = [];
  private posBuffer: string[] = [];
  
  constructor(private kire: Kire) {}

  public async compile(nodes: Node[]): Promise<string> {
    this.preBuffer = [];
    this.resBuffer = [];
    this.posBuffer = [];

    this.resBuffer.push(`with($ctx) {`);

    // Hook: onBewareDirectives
    if (this.kire.hooks?.onBewareDirectives) {
        if (Array.isArray(this.kire.hooks.onBewareDirectives)) {
            for (const hook of this.kire.hooks.onBewareDirectives) {
                // Cast 'this' to any or ICompiler compatible type if needed, 
                // but AnalyticalCompiler implements compile(Node[]) which matches interface except private props.
                const injected = hook(this as any);
                if (typeof injected === 'string') {
                    this.resBuffer.push(injected);
                }
            }
        } else {
            const injected = this.kire.hooks.onBewareDirectives(this as any);
            if (typeof injected === 'string') {
                this.resBuffer.push(injected);
            }
        }
    }

    // Compile the root nodes
    await this.compileNodes(nodes);

    this.resBuffer.push(`}`); // Close with($ctx)

    const pre = this.preBuffer.join('\n');
    const res = this.resBuffer.join('\n');
    const pos = this.posBuffer.join('\n');
    
    // Return statement must be last
    const ret = `return $ctx;`;

    return `${pre}\n${res}\n${pos}\n${ret}`;
  }

  private async compileNodes(nodes: Node[]) {
    for (const node of nodes) {
      if (node.type === 'text') {
        if (node.content) {
            this.resBuffer.push(`$ctx[Symbol.for('~response')] += ${JSON.stringify(node.content)};`);
        }
      } else if (node.type === 'variable') {
        if (node.content) {
            // Simple interpolation
            this.resBuffer.push(`$ctx[Symbol.for('~response')] += (${node.content});`);
        }
      } else if (node.type === 'directive') {
        await this.processDirective(node);
      }
    }
  }

  private async processDirective(node: Node) {
    const name = node.name;
    if (!name) return;

    // Check if directive exists in Kire instance
    const directive = this.kire.getDirective(name);
    
    if (!directive) {
        // Handle unknown directive with loc info
        if (node.loc) {
            console.warn(`[${node.loc.source}:${node.loc.start.line}:${node.loc.start.column}] Directive @${name} not found.`);
        } else {
            console.warn(`Directive @${name} not found.`);
        }
        return;
    }

    const ctx: KireContext = {
      param: (key: string | number) => {
          if (typeof key === 'number') {
              return node.args?.[key];
          }
          if (directive.params && node.args) {
              const index = directive.params.findIndex(p => p.split(':')[0] === key);
              if (index !== -1) return node.args[index];
          }
          return undefined;
      },
      children: node.children,
      parents: node.related, // 'parents' in user logic map to 'related' nodes from parser
      set: async (nodes: Node[]) => {
          if (!nodes) return;
          await this.compileNodes(nodes);
      },
      render: async (content: string) => {
        return this.kire.compile(content);
      },
      resolve: (path: string) => {
          return this.kire.resolvePath(path);
      },
      func: (code: string) => {
         return `async function($ctx) { ${code} }`;
      },
      pre: (code: string) => {
        this.preBuffer.push(code);
      },
      res: (code: string) => {
        this.resBuffer.push(code);
      },
      pos: (code: string) => {
        this.posBuffer.push(code);
      },
      error: (msg: string) => {
        let errorMsg = `Error in directive @${name}`;
        if (node.loc) {
            errorMsg += ` at ${node.loc.source}:${node.loc.start.line}:${node.loc.start.column}`;
        }
        errorMsg += `: ${msg}`;
        throw new Error(errorMsg);
      },
      clone: (locals: Record<string, any> = {}) => {
          this.resBuffer.push(`$ctx.clone(${JSON.stringify(locals)});`);
          return ctx;
      },
      clear: () => {
          this.resBuffer.push(`$ctx.clear();`);
          return ctx;
      }
    };

    await directive.onCall(ctx);
  }
}

// --- From: packages/analytical/src/types.ts ---
declare module 'kire' {
    export interface Position {
        line: number;
        column: number;
        offset: number;
    }

    export interface NodeLocation {
        source: string;
        start: Position;
        end: Position;
    }

    export interface Node {
        loc?: NodeLocation;
    }
}


// --- From: packages/analytical/src/parser.ts ---
import type { Kire, Node, DirectiveDefinition } from 'kire';
import './types'; // This is for module augmentation

export class AnalyticalParser {
  private cursor = 0;
  private line = 1;
  private column = 1;
  private stack: Node[] = [];
  private rootChildren: Node[] = [];

  constructor(private template: string, private kire: Kire, private source = 'template') {}

  private getPosition() {
    return { line: this.line, column: this.column, offset: this.cursor };
  }

  public parse(): Node[] {
    this.cursor = 0;
    this.stack = [];
    this.rootChildren = [];
    
    while (this.cursor < this.template.length) {
      const remaining = this.template.slice(this.cursor);
      const startPos = this.getPosition();

      // Check for interpolation {{ ... }}
      const interpolationMatch = remaining.match(/^\{\{([\s\S]*?)\}\}/);
      if (interpolationMatch) {
        const fullMatch = interpolationMatch[0];
        const content = interpolationMatch[1]!.trim();
        this.advance(fullMatch);
        const endPos = this.getPosition();
        this.addNode({
          type: 'variable',
          content: content,
          start: startPos.offset,
          end: endPos.offset,
          loc: { source: this.source, start: startPos, end: endPos },
        });
        continue;
      }

      // Check for escaped directive @@
      if (remaining.startsWith('@@')) {
          this.advance('@@');
          const endPos = this.getPosition();
          this.addNode({
              type: 'text',
              content: '@',
              start: startPos.offset,
              end: endPos.offset,
              loc: { source: this.source, start: startPos, end: endPos },
          });
          continue;
      }

      // Check for directive @name(...)
      const directiveStartMatch = remaining.match(/^@(\w+)/);
      if (directiveStartMatch) {
        const [fullMatch, name] = directiveStartMatch;
        
        // Check if it has arguments
        let argsStr = undefined;
        let argsEndIndex = fullMatch.length;
        
        if (remaining.startsWith('(', fullMatch.length)) {
            // Parse arguments with balanced parentheses
            let depth = 1;
            let i = fullMatch.length + 1;
            let inQuote = false;
            let quoteChar = '';
            
            while (i < remaining.length && depth > 0) {
                const char = remaining[i];
                if ((char === '"' || char === "'") && remaining[i-1] !== '\\') {
                    if (inQuote && char === quoteChar) {
                        inQuote = false;
                    } else if (!inQuote) {
                        inQuote = true;
                        quoteChar = char;
                    }
                }
                
                if (!inQuote) {
                    if (char === '(') depth++;
                    else if (char === ')') depth--;
                }
                i++;
            }
            
            if (depth === 0) {
                argsStr = remaining.slice(fullMatch.length + 1, i - 1);
                argsEndIndex = i;
            }
        }

        if (name === 'end') {
            const popped = this.handleEndDirective();
            if (popped) {
                this.advance(remaining.slice(0, argsEndIndex)); // Advance full length
                popped.end = this.cursor;
                if (popped.loc) popped.loc.end = this.getPosition();
            } else {
                this.advance(remaining.slice(0, argsEndIndex));
            }
            continue;
        }

        const directiveDef = this.kire.getDirective(name!);
        
        // Check for sub-directive (parent logic)
        if (this.stack.length > 0) {
            const currentParent = this.stack[this.stack.length - 1];
            const parentDef = this.kire.getDirective(currentParent!.name!);
            
            if (parentDef?.parents) {
                const subDef = parentDef.parents.find(p => p.name === name);
                if (subDef) {
                    this.handleSubDirective(name!, argsStr, remaining.slice(0, argsEndIndex), currentParent!, subDef, startPos);
                    this.advance(remaining.slice(0, argsEndIndex));
                    continue;
                }
            }
        }

        // If not a registered directive treat as text
        if (!directiveDef) {
             this.advance(fullMatch); // Only advance the name part? 
             // If we advanced fully, we'd swallow args of unknown directive.
             // Existing logic treated it as text: `this.advance(fullMatch)`.
             // Here `fullMatch` is just `@name`.
             // So we output `@name` and args remain as text next loop.
             // Wait, next loop `(` starts args. `(` is treated as text.
             // So `@foo(bar)` becomes `@foo` (text) + `(bar)` (text). Correct.
             
             const endPos = this.getPosition();
             this.addNode({
                 type: 'text',
                 content: fullMatch,
                 start: startPos.offset,
                 end: endPos.offset,
                 loc: { source: this.source, start: startPos, end: endPos },
             });
             continue;
        }

        const args = argsStr ? this.parseArgs(argsStr) : [];
        
        // Calculate end pos before advance? No, usually we advance.
        // We need to advance `argsEndIndex`.
        const contentStr = remaining.slice(0, argsEndIndex);
        this.advance(contentStr);
        const endPos = this.getPosition();

        const node: Node = {
          type: 'directive',
          name: name,
          args: args,
          start: startPos.offset,
          end: endPos.offset,
          loc: { source: this.source, start: startPos, end: endPos },
          children: [],
          related: []
        };
        this.addNode(node);

        if (directiveDef.children) {
            this.stack.push(node);
        }
        
        continue;
      }

      // Text
      const nextInterpolation = remaining.indexOf('{{');
      const nextDirective = remaining.indexOf('@');
      
      let nextIndex = -1;
      if (nextInterpolation !== -1 && nextDirective !== -1) {
        nextIndex = Math.min(nextInterpolation, nextDirective);
      } else if (nextInterpolation !== -1) {
        nextIndex = nextInterpolation;
      } else if (nextDirective !== -1) {
        nextIndex = nextDirective;
      }

      if (nextIndex === -1) {
        this.advance(remaining);
        const endPos = this.getPosition();
        this.addNode({
          type: 'text',
          content: remaining,
          start: startPos.offset,
          end: endPos.offset,
          loc: { source: this.source, start: startPos, end: endPos },
        });
      } else {
        const text = remaining.slice(0, nextIndex > 0 ? nextIndex : 1);
        this.advance(text);
        const endPos = this.getPosition();
        this.addNode({
          type: 'text',
          content: text,
          start: startPos.offset,
          end: endPos.offset,
          loc: { source: this.source, start: startPos, end: endPos },
        });
      }
    }
    
    return this.rootChildren;
  }

  private handleEndDirective(): Node | undefined {
      if (this.stack.length === 0) return undefined;
      const popped = this.stack.pop();
      
      if (this.stack.length > 0) {
          const parent = this.stack[this.stack.length - 1];
          if (parent?.related?.includes(popped!)) {
              // This is a chained directive like `@elseif`, so its parent (`@if`) should be closed by the same `@end`
              return this.stack.pop();
          }
      }
      return popped;
  }

  private handleSubDirective(name: string, argsStr: string | undefined, fullMatch: string, parentNode: Node, subDef: DirectiveDefinition, startPos: any) {
      const args = argsStr ? this.parseArgs(argsStr) : [];
      this.advance(fullMatch);
      const endPos = this.getPosition();
      
      const node: Node = {
          type: 'directive',
          name: name,
          args: args,
          start: startPos.offset,
          end: endPos.offset,
          loc: { source: this.source, start: startPos, end: endPos },
          children: [],
          related: []
      };
      
      parentNode.related ??= [];
      parentNode.related.push(node);
      
      if (subDef.children) {
          // Pop the parent `if` and push the `elseif`
          this.stack.pop();
          this.stack.push(parentNode);
          this.stack.push(node);
      }
  }

  private addNode(node: Node) {
      if (this.stack.length > 0) {
          const current = this.stack[this.stack.length - 1];
          current!.children ??= [];
          current!.children.push(node);
      } else {
          this.rootChildren.push(node);
      }
  }

  private advance(str: string) {
    const lines = str.split('\n');
    if (lines.length > 1) {
      this.line += lines.length - 1;
      this.column = lines[lines.length - 1]!.length + 1;
    } else {
      this.column += str.length;
    }
    this.cursor += str.length;
  }

  private parseArgs(argsStr: string): any[] {
     const args: any[] = [];
     let current = '';
     let inQuote = false;
     let quoteChar = '';
     let braceDepth = 0;
     let bracketDepth = 0;
     let parenDepth = 0;
     
     for (let i = 0; i < argsStr.length; i++) {
       const char = argsStr[i];
       
       if ((char === '"' || char === "'") && (i === 0 || argsStr[i-1] !== '\\')) {
         if (inQuote && char === quoteChar) {
           inQuote = false;
         } else if (!inQuote) {
           inQuote = true;
           quoteChar = char;
         }
       }
       
       if (!inQuote) {
           if (char === '{') braceDepth++;
           else if (char === '}') braceDepth--;
           else if (char === '[') bracketDepth++;
           else if (char === ']') bracketDepth--;
           else if (char === '(') parenDepth++;
           else if (char === ')') parenDepth--;
       }
       
       if (char === ',' && !inQuote && braceDepth === 0 && bracketDepth === 0 && parenDepth === 0) {
         args.push(current.trim());
         current = '';
       } else {
         current += char;
       }
     }
     if (current) args.push(current.trim());
     
     return args.map(arg => {
         if ((arg.startsWith('"') && arg.endsWith('"')) || (arg.startsWith("'") && arg.endsWith("'"))) {
             return arg.slice(1, -1);
         }
         if (arg === 'true') return true;
         if (arg === 'false') return false;
         if (!isNaN(Number(arg))) return Number(arg);
         return arg;
     });
  }
}


// --- From: packages/analytical/src/index.ts ---
import type { KirePlugin, Kire } from 'kire';
import { AnalyticalParser } from './parser';
import { AnalyticalCompiler } from './compiler';
import './types';

export const KireAnalytical:KirePlugin = {
    name:"@kirejs/analytical",
    options:{},
    load(kire, opts) {
        // This plugin can be used to automatically set the engine
        kire.parserConstructor = AnalyticalParser;
        kire.compilerConstructor = AnalyticalCompiler;
    },
}

export default KireAnalytical;
export { AnalyticalParser } from './parser';
export { AnalyticalCompiler } from './compiler';

