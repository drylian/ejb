// Combined source for @kirejs/markdown

// --- From: packages/markdown/src/index.ts ---
import type { Kire, KirePlugin } from "kire";
import { marked } from "marked";

declare module "kire" {
	interface Kire {
		parseMarkdown(content: string): Promise<string>;
	}
}

export type MarkdownOptions = {};

export const KireMarkdown: KirePlugin<MarkdownOptions> = {
	name: "@kirejs/markdown",
	options: {},
	load(kire: Kire, _opts) {
		const cache = kire.cached<string>("@kirejs/markdown");
		// Expose parser for other plugins (like SSG)
		kire.parseMarkdown = async (content: string) => {
			return marked.parse(content) as
				| Promise<string>
				| string as Promise<string>;
		};

		// Runtime helper for processing markdown (file or string) with cache
		kire.$ctx("renderMarkdown", async (source: string) => {
			if (!source) return "";

			// Check cache first (key is the source string/path)
			if (cache.has(source)) {
				return cache.get(source)!;
			}

			let content = source;
			if (source.endsWith(".md") || source.endsWith(".markdown")) {
				try {
					const path = kire.resolvePath(source);
					const fs = await import("node:fs/promises");
					content = await fs.readFile(path, "utf-8");
				} catch (e) {
					// Fallback to treating as string if file fails
					content = source;
				}
			}

			const html = (await marked.parse(content)) as string;
			cache.set(source, html);
			return html;
		});

		kire.directive({
			name: "markdown",
			params: ["source:string"],
			async onCall(ctx) {
				const source = ctx.param(0) ?? "";

				// 1. Check if it is a glob pattern (SSG layout mode)
				if (source.includes("*")) {
					ctx.raw(`$ctx.res("<!-- KIRE_MARKDOWN_GEN:${source} -->");`);
					return;
				}

				// 2. Normal Mode
				ctx.raw(`await (async () => {
                    const html = await $ctx.renderMarkdown(${JSON.stringify(source)});
                    $ctx.res(html);
                })();`);
			},
		});
	},
};

export default KireMarkdown;


