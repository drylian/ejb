
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kire Client Example</title>
    <script>(() => {
  let activeEffect = null;
  const escapeAttrName = (name) => name.replace(/:/g, "\\:"), buildAttrSelector = (attr, value) => `[${ escapeAttrName(attr)}=${ JSON.stringify(value)}]`, updateAttributes = (target, source) => {
    Array.from(target.attributes).forEach((attr) => {
      if (!source.hasAttribute(attr.name))
        target.removeAttribute(attr.name);
    });
    Array.from(source.attributes).forEach((attr) => {
      if (target.getAttribute(attr.name) !== attr.value) {
        target.setAttribute(attr.name, attr.value);
        if (attr.name === "value" && "value" in target && target.value !== attr.value)
          target.value = attr.value;
        if (attr.name === "checked" && "checked" in target)
          target.checked = !0;
      }
    });
  }, patch = (parent, newChild, oldChild) => {
    if (!oldChild) {
      parent.appendChild(newChild);
      return;
    }
    if (oldChild.nodeType === newChild.nodeType && oldChild.nodeName === newChild.nodeName) {
      if (oldChild.nodeType === Node.TEXT_NODE) {
        if (oldChild.nodeValue !== newChild.nodeValue)
          oldChild.nodeValue = newChild.nodeValue;
      } else if (oldChild.nodeType === Node.ELEMENT_NODE) {
        const elOld = oldChild, elNew = newChild;
        updateAttributes(elOld, elNew);
        const oldKids = Array.from(elOld.childNodes), newKids = Array.from(elNew.childNodes), max = Math.max(oldKids.length, newKids.length);
        for (let i = 0;i < max; i++)
          if (i >= newKids.length)
            elOld.removeChild(oldKids[i]);
          else
            patch(elOld, newKids[i], oldKids[i]);
      }
    } else
      parent.replaceChild(newChild, oldChild);
  }, varLocals = new WeakMap;
  let currentElement = null;
  const resolveLocal = (start, name) => {
    let el = start;
    while (el) {
      const locals = varLocals.get(el);
      if (locals && name in locals)
        return locals[name];
      el = el.parentElement;
    }
    return;
  }, localsProxy = new Proxy({}, {
    get(_target, prop) {
      if (typeof prop === "symbol")
        return;
      if (!currentElement)
        return;
      return resolveLocal(currentElement, String(prop));
    },
    has(_target, prop) {
      if (typeof prop === "symbol")
        return !1;
      if (!currentElement)
        return !1;
      return resolveLocal(currentElement, String(prop)) !== void 0;
    }
  }), createSignal = (initialValue) => {
    let value = initialValue;
    const subscribers = new Set, read = () => {
      if (activeEffect) {
        subscribers.add(activeEffect);
        activeEffect.deps.add(subscribers);
      }
      return value;
    }, write = (newValue) => {
      if (typeof newValue === "function")
        value = newValue(value);
      else
        value = newValue;
      [...subscribers].forEach((eff) => eff.execute());
      return value;
    }, signal = (...args) => {
      if (args.length === 0)
        return read();
      return write(args[0]);
    };
    signal.__kireSignal = !0;
    signal.toString = () => String(read());
    signal.toJSON = () => read();
    signal[Symbol.iterator] = function* () {
      const v = read();
      if (Array.isArray(v))
        yield* v;
    };
    if (typeof initialValue === "function")
      createEffect(() => {
        const newValue = initialValue();
        if (newValue !== value)
          write(newValue);
      });
    return signal;
  }, createEffect = (fn) => {
    const effect = {
      execute: () => {
        cleanupDeps();
        const prev = activeEffect;
        activeEffect = effect;
        try {
          fn();
        } finally {
          activeEffect = prev;
        }
      },
      deps: new Set
    }, cleanupDeps = () => {
      effect.deps.forEach((sub) => sub.delete(effect));
      effect.deps.clear();
    };
    effect.execute();
    return cleanupDeps;
  }, scanAndBind = (root, scope) => {
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, null);
    let node = walker.currentNode;
    while (node) {
      const targetNode = node;
      if (targetNode.__kire_cleanups) {
        targetNode.__kire_cleanups.forEach((fn) => fn());
        targetNode.__kire_cleanups = [];
      } else
        targetNode.__kire_cleanups = [];
      const addCleanup = (fn) => {
        targetNode.__kire_cleanups.push(fn);
      };
      if (targetNode.nodeType === Node.TEXT_NODE && targetNode.textContent && targetNode.textContent.includes("{{")) {
        const originalText = targetNode.textContent, exprRegex = /{{(.*?)}}/g, bindings = [];
        let match;
        while (match = exprRegex.exec(originalText)) {
          const raw = match[0], code = match[1]?.trim();
          if (!code)
            continue;
          try {
            const exprFn = Function("scope", `with(scope) { return ${ code} }`);
            bindings.push({ raw, fn: exprFn });
          } catch (e) {
            console.error("[Kire] Error compiling", code, e);
          }
        }
        if (bindings.length) {
          const stop = createEffect(() => {
            let newText = originalText;
            bindings.forEach(({ raw, fn }) => {
              try {
                let result = fn(scope);
                if (typeof result === "function")
                  result = result();
                newText = newText.replace(raw, result === void 0 || result === null ? "" : String(result));
              } catch (e) {
                console.error("[Kire] Error evaluating", raw, e);
              }
            });
            if (targetNode.textContent !== newText)
              targetNode.textContent = newText;
          });
          addCleanup(stop);
        }
      }
      if (targetNode.nodeType === Node.ELEMENT_NODE) {
        const el = targetNode;
        Array.from(el.attributes).forEach((attr) => {
          const { name, value } = attr;
          if (value.includes("{{")) {
            const code = value.replace(/{{|}}/g, "").trim();
            if (!code)
              return;
            if (name.startsWith("on")) {
              const eventName = name.substring(2);
              el.removeAttribute(name);
              let handler;
              try {
                handler = Function("scope", "$event", `with(scope) { ${ code} }`);
              } catch (err) {
                console.error("[Kire] Event compile error", code, err);
                return;
              }
              const listener = function(e) {
                try {
                  handler.call(el, scope, e);
                } catch (err) {
                  console.error("[Kire] Event Error", code, err);
                }
              };
              el.addEventListener(eventName, listener);
              addCleanup(() => el.removeEventListener(eventName, listener));
            } else if (name === "kire:ref")
              ;
            else {
              let attrFn;
              try {
                attrFn = Function("scope", `with(scope) { return ${ code} }`);
              } catch (e) {
                console.error("[Kire] Attr compile error", code, e);
                return;
              }
              const stop = createEffect(() => {
                try {
                  let result = attrFn(scope);
                  if (typeof result === "function")
                    result = result();
                  el.setAttribute(name, String(result));
                } catch (e) {}
              });
              addCleanup(stop);
            }
            return;
          }
          if (name.startsWith("on")) {
            const trimmed = value.trim();
            if (trimmed.startsWith("it.")) {
              const eventName = name.substring(2);
              el.removeAttribute(name);
              let handlerFn;
              try {
                handlerFn = Function("$locals", "$event", `with($locals) { ${ trimmed} }`);
              } catch (err) {
                console.error("[Kire] Event compile error (it.*) " + trimmed, err);
                return;
              }
              const listener = function(e) {
                const prev = currentElement;
                currentElement = el;
                try {
                  handlerFn.call(el, localsProxy, e);
                } catch (err) {
                  console.error("[Kire] Event Error (it.*) " + trimmed, err);
                } finally {
                  currentElement = prev;
                }
              };
              el.addEventListener(eventName, listener);
              addCleanup(() => el.removeEventListener(eventName, listener));
            }
          }
        });
      }
      node = walker.nextNode();
    }
  }, assignLoopLocals = (root, scope) => {
    const liNodes = Array.from(root.querySelectorAll("li"));
    if (!liNodes.length)
      return;
    const keys = Object.keys(scope);
    for (const key of keys) {
      const candidate = scope[key];
      if (!candidate || typeof candidate !== "function" || !candidate.__kireSignal)
        continue;
      let arr;
      try {
        arr = candidate();
      } catch {
        continue;
      }
      if (!Array.isArray(arr))
        continue;
      const singular = key.endsWith("s") && key.length > 1 ? key.slice(0, -1) : key;
      liNodes.forEach((li, index) => {
        if (index >= arr.length)
          return;
        const value = arr[index], stack = [li];
        while (stack.length) {
          const el = stack.pop(), locals = varLocals.get(el) || {};
          locals[singular] = value;
          if (!("it" in locals))
            locals.it = scope;
          varLocals.set(el, locals);
          for (const child of Array.from(el.children))
            stack.push(child);
        }
      });
    }
  }, Kire = {
    store: {},
    state: createSignal,
    effect: createEffect,
    ref: (name, root = document) => root.querySelector(buildAttrSelector("kire:ref", name)),
    reactive: (name, setup) => {
      const scope = setup();
      Kire.store[name] = scope;
      const el = Kire.ref(name);
      if (el) {
        const existing = varLocals.get(el) || {};
        existing.it = scope;
        varLocals.set(el, existing);
        scanAndBind(el, scope);
      }
    },
    mount: (refName, renderFn) => {
      let attempts = 0;
      const tryMount = () => {
        const scope = Kire.store[refName];
        if (scope) {
          const iterator = document.createNodeIterator(document.body, NodeFilter.SHOW_COMMENT);
          let currentNode, targetNode = null;
          while (currentNode = iterator.nextNode())
            if (currentNode.textContent && currentNode.textContent.trim() === "$" + refName) {
              targetNode = currentNode;
              break;
            }
          if (targetNode && targetNode.parentNode) {
            const parent = targetNode.parentNode, container = document.createElement("span");
            container.setAttribute("data-kire-mount", refName);
            parent.insertBefore(container, targetNode);
            parent.removeChild(targetNode);
            const rootEl = Kire.ref(refName);
            if (rootEl) {
              const existing = varLocals.get(rootEl) || {};
              if (!("it" in existing))
                existing.it = scope;
              varLocals.set(rootEl, existing);
            }
            createEffect(() => {
              const ctx = {
                "~res": "",
                res: (s) => ctx["~res"] += s
              };
              renderFn(ctx, scope);
              const html = ctx["~res"] || "", tpl = document.createElement("template");
              tpl.innerHTML = html;
              const oldKids = Array.from(container.childNodes), newKids = Array.from(tpl.content.childNodes), max = Math.max(oldKids.length, newKids.length);
              for (let i = 0;i < max; i++)
                if (i >= newKids.length)
                  container.removeChild(oldKids[i]);
                else
                  patch(container, newKids[i], oldKids[i]);
              if (rootEl) {
                assignLoopLocals(rootEl, scope);
                scanAndBind(rootEl, scope);
              }
            });
          }
        } else {
          attempts += 1;
          if (attempts < 100)
            setTimeout(tryMount, 10);
          else
            console.warn("[Kire] Mount failed: Store for " + refName + " not found.");
        }
      };
      setTimeout(tryMount, 0);
    },
    varLocals,
    localsProxy,
    _getCurrentElement: () => currentElement
  }, win = window;
  win.$kire = Kire;
  win.$state = Kire.state;
  win.$effect = Kire.effect;
  win.$reactive = Kire.reactive;
  win.$mount = Kire.mount;
  win.$ref = Kire.ref;
})();</script>
    <style>
        body { font-family: sans-serif; padding: 2rem; }
        .card { border: 1px solid #ccc; padding: 1rem; border-radius: 8px; max-width: 300px; margin-top: 1rem; }
        button { background: #007bff; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer; }
        button:hover { background: #0056b3; }
    </style>
</head>
<body>
    <h1>Kire Client Side Interactivity</h1>
    
    <div kire:ref="counter-app" class="card">
        <!-- The client directive mounts the logic here -->
        <!-- $counter-app --><script>$kire.mount("counter-app", async ($ctx, $scope) => {  const it = $scope || { count: 0 };with($ctx) { 

$ctx['~res'] += "\n            <h2>Counter: ";
$ctx['~res'] += (it.count);
$ctx['~res'] += "</h2>\n            <p>Double: ";
$ctx['~res'] += (it.double());
$ctx['~res'] += "</p>\n            <!-- AQUI: sem ";
$ctx['~res'] += ", deixamos it.increment() literal -->\n            <button onclick=\"it.increment()\">Increment</button>\n        ";

return $ctx;
 }});</script>
    </div>

    <script>$kire.reactive("counter-app", () => {
        // This code runs on the client
        let count = $state(0);
        
        // Derived state (computed)
        let double = $state(() => count() * 2);

        const increment = () => {
            console.log('Incrementing', count());
            count(prev => prev + 1);
        };

        return {
            count,
            double,
            increment
        };
    });</script>

    <div kire:ref="todo-app" class="card">
        <!-- $todo-app --><script>$kire.mount("todo-app", async ($ctx, $scope) => {  const it = $scope || { todos: [], text: '' };with($ctx) { 

$ctx['~res'] += "\n            <h2>Todos</h2>\n            <!-- value ainda pode usar ";
$ctx['~res'] += ", é só renderização -->\n            <input\n                type=\"text\"\n                value=\"";
$ctx['~res'] += (it.text);
$ctx['~res'] += "\"\n                oninput=\"it.text(this.value)\"\n                placeholder=\"Add todo...\"\n            />\n            <button onclick=\"it.add()\">Add</button>\n            <ul>\n                ";
for (const todo of it.todos) {
$ctx['~res'] += "\n                     <li>\n                         ";
$ctx['~res'] += (todo);
$ctx['~res'] += "\n                         <button\n                             onclick=\"it.remove(todo)\"\n                             style=\"font-size:0.8em; padding:2px 5px; margin-left:5px; background:red;\"\n                         >\n                             x\n                         </button>\n                     </li>\n                ";
}
$ctx['~res'] += "\n            </ul>\n        ";

return $ctx;
 }});</script>
    </div>

    <script>$kire.reactive("todo-app", () => {
        let todos = $state(['Buy Milk', 'Walk Dog']);
        let text = $state('');

        const add = () => {
            if (!text()) return;
            todos(prev => [...prev, text()]);
            text('');
        };

        const remove = (item) => {
             todos(prev => prev.filter(t => t !== item));
        };

        return {
            todos,
            text,
            add,
            remove
        };
    });</script>

    <div kire:ref="form-app" class="card">
        <!-- $form-app --><script>$kire.mount("form-app", async ($ctx, $scope) => {  const it = $scope || { name: '', email: '' };with($ctx) { 

$ctx['~res'] += "\n            <h2>Form Example</h2>\n            <form onsubmit=\"it.submit($event)\">\n                <div style=\"margin-bottom: 10px;\">\n                    <label>Name:</label>\n                    <input type=\"text\" value=\"";
$ctx['~res'] += (it.name);
$ctx['~res'] += "\" oninput=\"it.name(this.value)\" placeholder=\"Your name\" />\n                </div>\n                <div style=\"margin-bottom: 10px;\">\n                    <label>Email:</label>\n                    <input type=\"email\" value=\"";
$ctx['~res'] += (it.email);
$ctx['~res'] += "\" oninput=\"it.email(this.value)\" placeholder=\"Your email\" />\n                </div>\n                <button type=\"submit\">Submit</button>\n            </form>\n            <p>Preview: ";
$ctx['~res'] += (it.name);
$ctx['~res'] += " <span style=\"color: #888\">";
$ctx['~res'] += (it.email ? '(' + it.email + ')' : '');
$ctx['~res'] += "</span></p>\n        ";

return $ctx;
 }});</script>
    </div>

    <script>$kire.reactive("form-app", () => {
        let name = $state('');
        let email = $state('');

        const submit = (e) => {
            e.preventDefault();
            alert('Form submitted!\nName: ' + name() + '\nEmail: ' + email());
            name('');
            email('');
        };

        return { name, email, submit };
    });</script>

</body>
</html>
