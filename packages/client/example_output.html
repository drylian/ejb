
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kire Client Example</title>
    <script>(() => {
  let activeEffect = null;
  const escapeAttrName = (name) => name.replace(/:/g, "\\:"), buildAttrSelector = (attr, value) => `[${escapeAttrName(attr)}=${JSON.stringify(value)}]`, varLocals = new WeakMap;
  let currentElement = null;
  const resolveLocal = (start, name) => {
    let el = start;
    while (el) {
      const locals = varLocals.get(el);
      if (locals && name in locals)
        return locals[name];
      el = el.parentElement;
    }
    return;
  }, localsProxy = new Proxy({}, {
    get(_target, prop) {
      if (typeof prop === "symbol")
        return;
      if (!currentElement)
        return;
      return resolveLocal(currentElement, String(prop));
    },
    has(_target, prop) {
      if (typeof prop === "symbol")
        return !1;
      if (!currentElement)
        return !1;
      return resolveLocal(currentElement, String(prop)) !== void 0;
    }
  }), createSignal = (initialValue) => {
    let value = initialValue;
    const subscribers = new Set, read = () => {
      if (activeEffect)
        subscribers.add(activeEffect);
      return value;
    }, write = (newValue) => {
      if (typeof newValue === "function")
        value = newValue(value);
      else
        value = newValue;
      [...subscribers].forEach((fn) => fn());
      return value;
    }, signal = (...args) => {
      if (args.length === 0)
        return read();
      return write(args[0]);
    };
    signal.__kireSignal = !0;
    signal.toString = () => String(read());
    signal.toJSON = () => read();
    signal[Symbol.iterator] = function* () {
      const v = read();
      if (Array.isArray(v))
        yield* v;
    };
    if (typeof initialValue === "function")
      createEffect(() => {
        const newValue = initialValue();
        if (newValue !== value)
          write(newValue);
      });
    return signal;
  }, createEffect = (fn, deps, debounceMs = 0) => {
    let timeout;
    const work = () => {
      fn();
    }, run = () => {
      if (debounceMs > 0) {
        clearTimeout(timeout);
        timeout = setTimeout(() => {
          activeEffect = run;
          work();
          activeEffect = null;
        }, debounceMs);
      } else {
        activeEffect = run;
        work();
        activeEffect = null;
      }
    };
    if (deps && Array.isArray(deps) && deps.length) {
      activeEffect = run;
      deps.forEach((d) => {
        if (typeof d === "function")
          d();
      });
      activeEffect = null;
      work();
    } else
      run();
    return run;
  }, scanAndBind = (root, scope) => {
    const walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, null);
    let node = walker.currentNode;
    while (node) {
      const targetNode = node;
      if (targetNode.nodeType === Node.TEXT_NODE && targetNode.textContent && targetNode.textContent.includes("{{")) {
        const originalText = targetNode.textContent, exprRegex = /{{(.*?)}}/g, bindings = [];
        let match;
        while (match = exprRegex.exec(originalText)) {
          const raw = match[0], code = match[1].trim();
          try {
            const exprFn = Function("scope", `with(scope) { return ${code} }`);
            bindings.push({ raw, fn: exprFn });
          } catch (e) {
            console.error("[Kire] Error compiling", code, e);
          }
        }
        if (bindings.length)
          createEffect(() => {
            let newText = originalText;
            bindings.forEach(({ raw, fn }) => {
              try {
                let result = fn(scope);
                if (typeof result === "function")
                  result = result();
                newText = newText.replace(raw, result === void 0 || result === null ? "" : String(result));
              } catch (e) {
                console.error("[Kire] Error evaluating", raw, e);
              }
            });
            if (targetNode.textContent !== newText)
              targetNode.textContent = newText;
          });
      }
      if (targetNode.nodeType === Node.ELEMENT_NODE) {
        const el = targetNode;
        Array.from(el.attributes).forEach((attr) => {
          const { name, value } = attr;
          if (value.includes("{{")) {
            const code = value.replace(/{{|}}/g, "").trim();
            if (!code)
              return;
            if (name.startsWith("on")) {
              const eventName = name.substring(2);
              el.removeAttribute(name);
              let handler;
              try {
                handler = Function("scope", "$event", `with(scope) { ${code} }`);
              } catch (err) {
                console.error("[Kire] Event compile error", code, err);
                return;
              }
              el.addEventListener(eventName, function(e) {
                try {
                  handler.call(el, scope, e);
                } catch (err) {
                  console.error("[Kire] Event Error", code, err);
                }
              });
            } else if (name === "kire:ref")
              ;
            else {
              let attrFn;
              try {
                attrFn = Function("scope", `with(scope) { return ${code} }`);
              } catch (e) {
                console.error("[Kire] Attr compile error", code, e);
                return;
              }
              createEffect(() => {
                try {
                  let result = attrFn(scope);
                  if (typeof result === "function")
                    result = result();
                  el.setAttribute(name, String(result));
                } catch (e) {}
              });
            }
            return;
          }
          if (name.startsWith("on")) {
            const trimmed = value.trim();
            if (trimmed.startsWith("it.")) {
              const eventName = name.substring(2);
              el.removeAttribute(name);
              let handlerFn;
              try {
                handlerFn = Function("$locals", "$event", `with($locals) { ${trimmed} }`);
              } catch (err) {
                console.error("[Kire] Event compile error (it.*) " + trimmed, err);
                return;
              }
              el.addEventListener(eventName, function(e) {
                const prev = currentElement;
                currentElement = el;
                try {
                  handlerFn.call(el, localsProxy, e);
                } catch (err) {
                  console.error("[Kire] Event Error (it.*) " + trimmed, err);
                } finally {
                  currentElement = prev;
                }
              });
            }
          }
        });
      }
      node = walker.nextNode();
    }
  }, assignLoopLocals = (root, scope) => {
    const liNodes = Array.from(root.querySelectorAll("li"));
    if (!liNodes.length)
      return;
    const keys = Object.keys(scope);
    for (const key of keys) {
      const candidate = scope[key];
      if (!candidate || typeof candidate !== "function" || !candidate.__kireSignal)
        continue;
      let arr;
      try {
        arr = candidate();
      } catch {
        continue;
      }
      if (!Array.isArray(arr))
        continue;
      const singular = key.endsWith("s") && key.length > 1 ? key.slice(0, -1) : key;
      liNodes.forEach((li, index) => {
        if (index >= arr.length)
          return;
        const value = arr[index], stack = [li];
        while (stack.length) {
          const el = stack.pop(), locals = varLocals.get(el) || {};
          locals[singular] = value;
          if (!("it" in locals))
            locals.it = scope;
          varLocals.set(el, locals);
          for (const child of Array.from(el.children))
            stack.push(child);
        }
      });
    }
  }, Kire = {
    store: {},
    state: createSignal,
    effect: createEffect,
    ref: (name, root = document) => root.querySelector(buildAttrSelector("kire:ref", name)),
    reactive: (name, setup) => {
      const scope = setup();
      Kire.store[name] = scope;
      const el = Kire.ref(name);
      if (el) {
        const existing = varLocals.get(el) || {};
        existing.it = scope;
        varLocals.set(el, existing);
        scanAndBind(el, scope);
      }
    },
    mount: (refName, renderFn) => {
      let attempts = 0;
      const tryMount = () => {
        const scope = Kire.store[refName];
        if (scope) {
          const iterator = document.createNodeIterator(document.body, NodeFilter.SHOW_COMMENT);
          let currentNode, targetNode = null;
          while (currentNode = iterator.nextNode())
            if (currentNode.textContent && currentNode.textContent.trim() === "$" + refName) {
              targetNode = currentNode;
              break;
            }
          if (targetNode && targetNode.parentNode) {
            const parent = targetNode.parentNode, container = document.createElement("span");
            container.setAttribute("data-kire-mount", refName);
            parent.insertBefore(container, targetNode);
            parent.removeChild(targetNode);
            const rootEl = Kire.ref(refName);
            if (rootEl) {
              const existing = varLocals.get(rootEl) || {};
              if (!("it" in existing))
                existing.it = scope;
              varLocals.set(rootEl, existing);
            }
            createEffect(() => {
              const ctx = {
                [Symbol.for("~response")]: "",
                res: (s) => ctx[Symbol.for("~response")] += s
              };
              renderFn(ctx, scope);
              const html = ctx[Symbol.for("~response")] || "", tpl = document.createElement("template");
              tpl.innerHTML = html;
              container.innerHTML = "";
              container.appendChild(tpl.content);
              if (rootEl) {
                assignLoopLocals(rootEl, scope);
                scanAndBind(rootEl, scope);
              }
            });
          }
        } else {
          attempts += 1;
          if (attempts < 100)
            setTimeout(tryMount, 10);
          else
            console.warn("[Kire] Mount failed: Store for " + refName + " not found.");
        }
      };
      setTimeout(tryMount, 0);
    },
    varLocals,
    localsProxy,
    _getCurrentElement: () => currentElement
  }, win = window;
  win.$kire = Kire;
  win.$state = Kire.state;
  win.$effect = Kire.effect;
  win.$reactive = Kire.reactive;
  win.$mount = Kire.mount;
  win.$ref = Kire.ref;
})();</script>
    <style>
        body { font-family: sans-serif; padding: 2rem; }
        .card { border: 1px solid #ccc; padding: 1rem; border-radius: 8px; max-width: 300px; margin-top: 1rem; }
        button { background: #007bff; color: white; border: none; padding: 0.5rem 1rem; border-radius: 4px; cursor: pointer; }
        button:hover { background: #0056b3; }
    </style>
</head>
<body>
    <h1>Kire Client Side Interactivity</h1>
    
    <div kire:ref="counter-app" class="card">
        <!-- The client directive mounts the logic here -->
        <!-- $counter-app --><script>$kire.mount("counter-app", async ($ctx, $scope) => {  const it = $scope || { count: 0 };
with($ctx) {
$ctx[Symbol.for('~response')] += "\n            <h2>Counter: ";
$ctx[Symbol.for('~response')] += (it.count);
$ctx[Symbol.for('~response')] += "</h2>\n            <p>Double: ";
$ctx[Symbol.for('~response')] += (it.double());
$ctx[Symbol.for('~response')] += "</p>\n            <!-- AQUI: sem ";
$ctx[Symbol.for('~response')] += ", deixamos it.increment() literal -->\n            <button onclick=\"it.increment()\">Increment</button>\n        ";
}

return $ctx;});</script>
    </div>

    <script>$kire.reactive("counter-app", () => {
        // This code runs on the client
        let count = $state(0);
        
        // Derived state (computed)
        let double = $state(() => count() * 2);

        const increment = () => {
            console.log('Incrementing', count());
            count(prev => prev + 1);
        };

        return {
            count,
            double,
            increment
        };
    });</script>

    <div kire:ref="todo-app" class="card">
        <!-- $todo-app --><script>$kire.mount("todo-app", async ($ctx, $scope) => {  const it = $scope || { todos: [], text: '' };
with($ctx) {
$ctx[Symbol.for('~response')] += "\n            <h2>Todos</h2>\n            <!-- value ainda pode usar ";
$ctx[Symbol.for('~response')] += ", é só renderização -->\n            <input\n                type=\"text\"\n                value=\"";
$ctx[Symbol.for('~response')] += (it.text);
$ctx[Symbol.for('~response')] += "\"\n                <!-- evento agora é it.text(this.value) direto -->\n                oninput=\"it.text(this.value)\"\n                placeholder=\"Add todo...\"\n            />\n            <button onclick=\"it.add()\">Add</button>\n            <ul>\n                ";
for (const todo of it.todos) {
$ctx[Symbol.for('~response')] += "\n                     <li>\n                         ";
$ctx[Symbol.for('~response')] += (todo);
$ctx[Symbol.for('~response')] += "\n                         <button\n                             onclick=\"it.remove(todo)\"\n                             style=\"font-size:0.8em; padding:2px 5px; margin-left:5px; background:red;\"\n                         >\n                             x\n                         </button>\n                     </li>\n                ";
}
$ctx[Symbol.for('~response')] += "\n            </ul>\n        ";
}

return $ctx;});</script>
    </div>

    <script>$kire.reactive("todo-app", () => {
        let todos = $state(['Buy Milk', 'Walk Dog']);
        let text = $state('');

        const add = () => {
            if (!text()) return;
            todos(prev => [...prev, text()]);
            text('');
        };

        const remove = (item) => {
             todos(prev => prev.filter(t => t !== item));
        };

        return {
            todos,
            text,
            add,
            remove
        };
    });</script>

</body>
</html>
