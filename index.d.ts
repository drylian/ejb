// Generated by dts-bundle-generator v9.5.1

/**
 * EJB Template Engine class
 */
export declare class Ejb {
	/** File resolver function */
	resolver: EjbContructor["resolver"];
	/** Default file extension */
	extension: EjbContructor["extension"];
	/** Global variables available in templates */
	globals: EjbContructor["globals"];
	/** Prefix configuration */
	globalvar: EjbContructor["globalvar"];
	/** Path aliases mapping */
	aliases: EjbContructor["aliases"];
	/** Root directory for file resolution */
	root: EjbContructor["root"];
	/** expose global keys in file, example: it.exemple -> it.exemple | exemple */
	globalexpose: boolean;
	/** Stores errors during compilation */
	errors: EjbError[];
	/**
	 * Returns the appropriate function constructor (AsyncFunction or Function)
	 * based on async mode
	 * @returns {FunctionConstructor} The function constructor to use
	 */
	getFunction: () => any;
	/** Registered directives */
	directives: EjbContructor["directives"];
	/**
	 * Compiles a template into a function string that can be executed later
	 * @param template - Template string or path to template file
	 * @returns The generated function code as string (wrapped in Promise if async)
	 */
	makeFunction(template: string): Promise<string>;
	/**
	 * Compiles AST node(s) to executable code or string
	 * @param node - AST node or array of nodes to compile
	 * @param stringMode - Whether to generate string output instead of executable code
	 * @returns Compiled code or string (wrapped in Promise if async)
	 */
	compile(node: AstNode | AstNode[], stringMode?: boolean): Promise<string>;
	/**
	 * Parses template string into AST
	 * @param code - Template string to parse
	 * @returns Root AST node
	 */
	parser(code: string): RootNode;
	/**
	 * Renders a template with provided locals
	 * @param template - Template string or path to template file
	 * @param locals - Variables to make available during rendering
	 * @returns Rendered output (wrapped in Promise if async)
	 */
	render(template: string, locals?: Record<string, any>): Promise<string>;
	/**
	 * Determines if a string is likely a template path
	 * @param template - String to check
	 * @returns True if string appears to be a path
	 */
	private isTemplatePath;
	/**
	 * Registers one or more directives
	 * @param directives - Directives to register
	 * @returns The Ejb instance for chaining
	 */
	register(...directives: (EjbDirectivePlugin | Record<string, EjbDirectivePlugin>)[]): this;
	/**
	 * Creates an Ejb instance
	 * @param opts - Configuration options
	 */
	constructor(opts?: Partial<EjbContructor>);
}
/**
 * EJB Builder class for SSR support
 * Extends Ejb with build capabilities
 */
export declare class EjbBuilder extends Ejb {
	/** Storage for compiled files with multiple loaders */
	files: Record<string, FileContent[]>;
	/** Current file being processed */
	private _currentFile;
	/** Current loader being used */
	private _currentLoader;
	/** Distribution directory for build output */
	dist: string;
	/** Build manifest cache */
	private manifest?;
	constructor(opts?: Partial<EjbContructor> & {
		dist?: string;
	});
	/**
	 * Sets the current file being processed
	 * @param filepath - Path to the file
	 */
	file(filepath: string): this;
	/**
	 * Gets the current file being processed
	 */
	get current(): string;
	/**
	 * Sets the current loader
	 * @param loader - Loader type to use
	 */
	load(loader: LoaderType): this;
	/**
	 * Gets the current loader
	 */
	get loader(): LoaderType;
	/**
	 * Adds content to the specified loader
	 * @param text - Content to add
	 * @param type - Loader type (defaults to current loader)
	 */
	res(text: string, type?: LoaderType): void;
	/**
	 * Builds all files and generates the manifest
	 * @returns Build manifest
	 */
	build(): Promise<BuildManifest>;
	/**
	 * Loads the build manifest from dist
	 */
	loadManifest(): Promise<BuildManifest>;
	/**
	 * Gets the entry file path for a template
	 * @param filepath - Template file path
	 */
	getEntry(filepath: string): Promise<string | undefined>;
	/**
	 * Gets the assets for a template
	 * @param filepath - Template file path
	 */
	getAssets(filepath: string): Promise<string[]>;
	/**
	 * Renders a template using the built files
	 * @param filepath - Template file path
	 * @param locals - Local variables
	 */
	renderBuilt(filepath: string, locals?: Record<string, any>): Promise<string>;
	/**
	 * Compiles a file with all loaders
	 * @param filepath - Path to the template file
	 */
	compileFile(filepath: string): Promise<void>;
}
/**
 * Reference to the AsyncFunction constructor
 */
export declare const AsyncFunction: any;
/**
 * Regular expression for parsing directive syntax:
 * - Captures directive name
 * - Optionally captures parameters in parentheses
 */
export declare const DIRECTIVE_REGEX: RegExp;
/**
 * File resolver implementation for Bun runtime environment
 * @param importpath - Path to the file to resolve
 * @returns Promise resolving to file contents or empty string on error
 *
 * @example
 * const content = await EJBBunResolver('./template.ejb');
 */
export declare const EJBBunResolver: (importpath: string) => Promise<string>;
/**
 * Creates a file resolver function for Node.js environments
 * @returns A resolver function that handles file reading
 *
 * @example
 * // Async resolver
 * const asyncResolver = EJBNodeJSResolver();
 */
export declare const EJBNodeJSResolver: () => (importpath: string) => Promise<string>;
/**
 * Default prefix for directives in templates
 */
export declare const EJB_DEFAULT_PREFIX_DIRECTIVE = "@";
/**
 * Default prefix for global variables in templates
 */
export declare const EJB_DEFAULT_PREFIX_GLOBAL = "it";
/**
 * Default prefix for variable interpolation in templates
 * Uses {{*}} syntax where * represents the variable name
 */
export declare const EJB_DEFAULT_PREFIX_VARIABLE = "{{*}}";
/**
 * Escaped prefix for directives in templates (e.g., @@directive)
 */
export declare const EJB_ESCAPED_PREFIX_DIRECTIVE = "@@";
/**
 * HTML escape character mappings
 */
export declare const ESCAPE_HTML: {
	"&": string;
	"<": string;
	">": string;
	"\"": string;
	"'": string;
};
/**
 * Regular expression for detecting characters that need HTML escaping
 */
export declare const ESPACE_HTML_REGEX: RegExp;
/**
 * Regular expression for html codes
 */
export declare const HTML_REGULAR_REGEX: RegExp;
/**
 * Escapes JavaScript string content for template literals
 * @param str - The string to escape
 * @returns Escaped string
 */
export declare const escapeJs: (str: string) => string;
/**
 * Resolves file paths with aliases and extensions
 */
export declare const filepathResolver: (ejb: AnyEjb, filepath: string, currentFile?: string) => string;
/**
 * Enum representing different AST node types in the template engine
 */
export declare enum EjbAst {
	/** Root node of the AST */
	Root = 0,
	/** Text content node */
	Text = 1,
	/** Variable interpolation node */
	Interpolation = 2,
	/** Directive node */
	Directive = 3,
	/** Sub-directive node */
	SubDirective = 4
}
export declare function compile(ejb: Ejb, ast: RootNode): Promise<string>;
/**
 * Helper function to create a directive plugin object
 * @param opts - Directive plugin object
 * @returns An object with the directive name as key and options as value
 */
export declare function ejbDirective(opts: EjbDirectivePlugin): Record<string, EjbDirectivePlugin>;
export declare function ejbParser(ejb: Ejb, template: string): RootNode;
/**
 * Escapes HTML special characters
 * @param value - Value to escape
 * @returns Escaped HTML string
 */
export declare function escapeHtml(value: any): string;
/**
 * Escapes special regex characters in a string
 * @param string - The string to escape
 * @returns The escaped string
 */
export declare function escapeRegExp(string: string): string;
/**
 * Escapes string
 */
export declare function escapeString(str: string): string;
export declare function generateNodeCode(ejb: Ejb, node: AstNode, parents?: AstNode[]): Promise<string>;
export declare function generateNodeString(ejb: Ejb, node: AstNode, parents?: AstNode[]): string;
/**
 * Joins path segments and normalizes the resulting path
 */
export declare function join(...segments: string[]): string;
export declare function md5(input: string): string;
/**
 * Wraps template code in an Ejb function wrapper
 * @param ejb - The Ejb instance
 * @param str - The code string to wrap
 * @returns Wrapped function code
 */
export declare function returnEjbRes(str: string): string;
export declare function trimQuotes(str: string): string;
/** Base interface for all AST nodes */
export interface AstNodeBase {
	/** Node type identifier */
	type: EjbAst;
	/** Flag indicating if directive was auto-closed */
	auto_closed?: boolean;
	loc?: SourceLocation;
}
export interface BuildManifest {
	paths: Record<string, {
		entry: string;
		assets: string[];
	}>;
}
/** Directive node */
export interface DirectiveNode extends AstNodeBase {
	type: EjbAst.Directive;
	/** Directive name */
	name: string;
	/** Directive expression */
	expression: string;
	/** Child nodes */
	children: AstNode[];
}
/**
 * Context for directive children processing
 */
export interface EjbChildrenContext {
	/** Child nodes */
	children: AstNode[];
	params?: EjbParamOption[];
	/** Parent directive names (for nested directives) */
	parents: AstNode[];
}
/**
 * Interface for Ejb constructor options
 * @template Async - Boolean indicating if the instance should work in async mode
 */
export interface EjbContructor {
	/** Path aliases mapping */
	aliases: Record<string, string>;
	/** Default file extension */
	extension: string;
	/** Root directory for file resolution */
	root: string;
	/** File resolver function */
	resolver: (path: string) => Promise<string>;
	/** Registered directives */
	directives: Record<string, EjbDirectivePlugin>;
	/** Global variables available in templates */
	globals: Record<string, any>;
	/** Global variable prefix (default 'it') */
	globalvar: string;
	/** expose global keys in file, example: it.exemple -> it.exemple | exemple */
	globalexpose: boolean;
}
/**
 * Base interface for directive definitions
 */
export interface EjbDirectiveBasement {
	/** Directive name */
	name: string | RegExp;
	params?: EjbParamOption[];
	children?: boolean;
	/**
	 * Handler for directive parameters
	 * @param ejb - Ejb instance
	 * @param expression - Directive expression content
	 * @returns Code to insert or Promise of code
	 */
	onParams?: (ejb: AnyEjb, exp: Expression, loc?: SourceLocation) => EjbAnyReturn<string | undefined>;
	/**
	 * Handler for when a regex name matches
	 * @param ejb - Ejb instance
	 * @param match - The match from the regex
	 * @returns Code to insert or Promise of code
	 */
	onNameResolver?: (ejb: AnyEjb, match: RegExpMatchArray) => EjbAnyReturn<string | undefined>;
	/**
	 * Handler for directive children
	 * @param ejb - Ejb instance
	 * @param opts - Children context
	 * @returns Code to insert or Promise of code
	 */
	onChildren?: (ejb: AnyEjb, opts: EjbChildrenContext) => EjbAnyReturn<string>;
	/**
	 * Initialization handler
	 * @param ejb - Ejb instance
	 * @returns Code to insert or Promise of code
	 */
	onInit?: (ejb: AnyEjb, exp: Expression, loc?: SourceLocation) => EjbAnyReturn<string>;
	/**
	 * Finalization handler
	 * @param ejb - Ejb instance
	 * @returns Code to insert or Promise of code
	 */
	onEnd?: (ejb: AnyEjb) => EjbAnyReturn<string>;
	/** Type of content within the directive's children */
	children_type?: "html" | "js" | "css";
	/** A description of what the directive does. */
	description?: string;
	/** An example of how to use the directive. */
	example?: string;
}
/**
 * Interface for parent directives that can have sub-directives
 */
export interface EjbDirectiveParent extends EjbDirectiveBasement {
	/** Flag indicating this is an internal directive */
	internal?: boolean;
	/** Flag indicating this directive requires an @end */
	withend?: boolean;
}
/**
 * Interface for complete directive plugin definition
 */
export interface EjbDirectivePlugin extends EjbDirectiveBasement {
	/** Flag indicating this directive can have children */
	children?: boolean;
	/** Processing priority (higher runs first) */
	priority?: number;
	/** Available sub-directives */
	parents?: EjbDirectiveParent[];
	/**
	 * File-level initialization handler
	 * @param ejb - Ejb instance
	 * @returns Code to insert or Promise of code
	 */
	onInitFile?: (ejb: AnyEjb) => EjbAnyReturn<string>;
	/**
	 * File-level finalization handler
	 * @param ejb - Ejb instance
	 * @returns Code to insert or Promise of code
	 */
	onEndFile?: (ejb: AnyEjb) => EjbAnyReturn<string>;
}
export interface EjbError extends Error {
	loc?: SourceLocation;
}
/**
 * Context object available during template execution
 */
export interface EjbFunctionContext {
	/** Ejb instance */
	ins: AnyEjb;
	/** Result buffer */
	res: string;
	/** HTML escaping function */
	escapeHtml: (str: string) => string;
	/** JavaScript escaping function */
	escapeJs: (str: string) => string;
	/** Function constructor (sync or async) */
	EjbFunction: (...args: any[]) => any;
}
export interface EjbParamOption {
	name: string;
	type: "string" | "boolean" | "number" | "object" | "array" | "html";
	required?: boolean;
	description?: string;
	default?: any;
}
export interface Expression {
	getString(name: string): string | undefined;
	getNumber(name: string): number | undefined;
	getBoolean(name: string): boolean | undefined;
	getObject<T>(name: string): T | undefined;
	getArray<T>(name: string): T[] | undefined;
	getRaw(name: string): string | undefined;
	raw: string;
}
export interface FileContent {
	loader: LoaderType;
	content: string;
}
/** Interpolation node */
export interface InterpolationNode extends AstNodeBase {
	type: EjbAst.Interpolation;
	/** Expression to evaluate */
	expression: string;
	/** Flag indicating if output should be HTML-escaped */
	escaped: boolean;
}
/** Root node of the AST */
export interface RootNode extends AstNodeBase {
	type: EjbAst.Root;
	errors: EjbError[];
	/** Child nodes */
	children: AstNode[];
}
export interface SourceLocation {
	start: Position$1;
	end: Position$1;
}
/** Sub-directive node */
export interface SubDirectiveNode extends AstNodeBase {
	type: EjbAst.SubDirective;
	/** Directive name */
	name: string;
	/** Directive expression */
	expression: string;
	/** Child nodes */
	children: AstNode[];
	/** Parent directive name */
	parent_name: string;
}
/** Text content node */
export interface TextNode extends AstNodeBase {
	type: EjbAst.Text;
	/** Text content */
	value: string;
}
/** Type representing any Ejb instance (sync or async) */
export type AnyEjb = Ejb | EjbBuilder;
/** Union type of all possible AST node types */
export type AstNode = RootNode | TextNode | DirectiveNode | InterpolationNode | SubDirectiveNode;
/** Type representing a value that can be either the type or a Promise of the type */
export type EjbAnyReturn<type> = type | Promise<type>;
export type LoaderType = "server" | "client" | "css";
interface Position$1 {
	line: number;
	column: number;
	offset: number;
}

export {
	Position$1 as Position,
};

export {};
