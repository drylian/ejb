// Combined source for kire

// --- From: core/src/types.ts ---
import type { Kire } from "./kire";

export interface KireCache<T = any> {
	get(key: string): T | undefined;
	set(key: string, value: T): void;
	has(key: string): boolean;
	delete(key: string): boolean;
	clear(): void;
	entries(): IterableIterator<[string, T]>;
}

export interface KireConfig {
	globals?: Record<string, any>;
	// Add other config options as needed
}

export interface IParser {
	parse(): Node[];
}
export type IParserConstructor = new (template: string, kire: Kire) => IParser;

export interface ICompiler {
	compile(nodes: Node[]): Promise<string>;
}
export type ICompilerConstructor = new (kire: Kire) => ICompiler;

export interface KireOptions {
	root?: string;
	production?: boolean;
	resolver?: (filename: string) => Promise<string>;
	alias?: Record<string, string>;
	extension?: string;
	directives?: boolean;
	plugins?: (KirePlugin | [KirePlugin, any])[];
	engine?: {
		parser?: IParserConstructor;
		compiler?: ICompilerConstructor;
	};
	varLocals?: string;
	exposeLocals?: boolean;
}

export interface KireContext {
	param(name: string | number): any;
	render(content: string): Promise<string>; // Returns compiled function string
	func(code: string): string; // Wraps code in a function definition
	
	// Local function scope
	pre(code: string): void;
	res(content: string): void;
	raw(code: string): void;
	pos(code: string): void;
	
	// Global scope (Main file)
	$pre(code: string): void;
	$pos(code: string): void;

	error(message: string): void;
	resolve(path: string): string;

	// For nested directives
	children?: Node[];
	parents?: Node[]; // The instances of sub-directives (e.g., elseif blocks)
	set(nodes: Node[]): Promise<void>;
}

export interface KireElementContext {
	content: string; // The global HTML content (mutable/readable state representation)
	element: {
		tagName: string;
		attributes: Record<string, string>;
		inner: string;
		outer: string;
	};
	// Method to update the global content
	update(newContent: string): void;
	replace(replacement: string): void;
	replaceContent(replacement: string): void;
}

export type KireElementHandler = (
	ctx: KireElementContext,
) => Promise<void> | void;

export interface KireElementOptions {
	void?: boolean;
}

export interface ElementDefinition {
	name: string | RegExp;
	description?: string;
	example?: string;
	void?: boolean;
	onCall: KireElementHandler;
}

export interface DirectiveDefinition {
	name: string;
	params?: string[]; // e.g. ['filepath:string']
	children?: boolean; // Does this directive accept a block ending with @end?
	childrenRaw?: boolean; // Should the children be treated as raw text?
	parents?: DirectiveDefinition[]; // Sub-directives like elseif/else
	onCall: (ctx: KireContext) => void | Promise<void>;
	once?: (ctx: KireContext) => void | Promise<void>;
	description?: string;
	example?: string;
	type?: "css" | "js" | "html";
}

export interface KireSchematic {
	package: string;
	repository?: string | { type: string; url: string };
	version?: string;
	directives?: DirectiveDefinition[];
	elements?: ElementDefinition[];
	globals?: Record<string, any>;
}

export interface KirePlugin<Options extends object | undefined = {}> {
	name: string;
	sort?: number;
	options: Options;
	load(kire: Kire, opts?: Options): void;
}

// AST Types
export type NodeType = "text" | "variable" | "directive";

export interface Node {
	type: NodeType;
	content?: string;
	name?: string; // For directives
	args?: any[]; // For directives
	start?: number;
	end?: number;
	children?: Node[]; // Inner content
	related?: Node[]; // For 'parents' (elseif, etc)
}


// --- From: core/src/kire.ts ---
import { Compiler } from "./compiler";
import { KireDirectives } from "./directives";
import { Parser } from "./parser";
import type {
	DirectiveDefinition,
	ElementDefinition,
	ICompilerConstructor,
	IParserConstructor,
	KireCache,
	KireElementHandler,
	KireElementOptions,
	KireOptions,
	KirePlugin,
	KireSchematic,
} from "./types";
import { md5 } from "./utils/md5";
import { resolvePath } from "./utils/resolve";

export class Kire {
	public $directives: Map<string, DirectiveDefinition> = new Map();
	public $elements: Set<ElementDefinition> = new Set();
	public $globals: Map<string, any> = new Map();

	public root: string;
	public production: boolean;
	public $resolver: (filename: string) => Promise<string>;
	public $readdir?: (pattern: string) => Promise<string[]>;
	public alias: Record<string, string>;
	public extension: string;
	public $files: Map<string, Function> = new Map();
	public $parser: IParserConstructor;
	public $compiler: ICompilerConstructor;
	public $var_locals: string;
	public $expose_locals: boolean;
	public $cache: Map<string, Map<string, any>> = new Map();

	public cacheClear() {
		this.$cache.clear();
		this.$files.clear();
	}

	public cached<T = any>(namespace: string): KireCache<T> {
		if (!this.$cache.has(namespace)) {
			this.$cache.set(namespace, new Map());
		}
		const store = this.$cache.get(namespace)!;
		return {
			get: (key: string) => store.get(key),
			set: (key: string, value: T) => store.set(key, value),
			has: (key: string) => store.has(key),
			delete: (key: string) => store.delete(key),
			clear: () => store.clear(),
			entries: () => store.entries(),
		};
	}

	constructor(options: KireOptions = {}) {
		this.root = options.root ?? "./";
		this.production = options.production ?? true;
		this.alias = options.alias ?? { "~/": this.root };
		this.extension = options.extension ?? "kire";
		this.$var_locals = options.varLocals ?? "it";
		this.$expose_locals = options.exposeLocals ?? true;

		this.$resolver =
			options.resolver ??
			(async (filename) => {
				throw new Error(`No resolver defined for path: ${filename}`);
			});

		this.$parser = options.engine?.parser ?? Parser;
		this.$compiler = options.engine?.compiler ?? Compiler;

		// Register internal helpers
		this.$ctx("$md5", md5);
		this.$ctx("~$pre", []);
		this.$ctx("~$pos", []);
		this.$ctx(
			"$require",
			async (path: string) => {
				// Use absolute path for caching key to avoid conflicts
				const resolvedPath = resolvePath(
					path,
					this.root,
					this.alias,
					this.extension,
				);

				const cached = this.cached("@kirejs/core");
				const isProd = this.production;
				const hash = cached.get(`md5:${resolvedPath}`);
				let content = "";

				if (!hash || !isProd) {
					try {
						content = await this.$resolver(resolvedPath);
					} catch (e: any) {
						if (!e.message.includes("No resolver")) {
							console.warn(`Failed to resolve path: ${resolvedPath}`, e);
						}
						return null;
					}

					if (!content) {
						return null;
					}

					const ihash = md5(content);

					if (!isProd && hash) {
						if (ihash === hash) {
							return cached.get(`js:${resolvedPath}`);
						}
						else {
							cached.delete(`md5:${resolvedPath}`);
							cached.delete(`js:${resolvedPath}`);
						}
					}

					const compiled = await this.compileFn(content);
					cached.set(`md5:${resolvedPath}`, ihash);
					cached.set(`js:${resolvedPath}`, compiled);
					return compiled;
				} else {
					return cached.get(`js:${resolvedPath}`);
				}
			}
		);

		// Collect plugins to load
		const pluginsToLoad: Array<{ p: KirePlugin<any>; o?: any }> = [];

		// Register default directives
		if (
			typeof options.directives === "undefined" ||
			options.directives === true
		) {
			pluginsToLoad.push({ p: KireDirectives });
		}

		// User provided plugins
		if (options.plugins) {
			for (const p of options.plugins) {
				if (Array.isArray(p)) {
					pluginsToLoad.push({ p: p[0], o: p[1] });
				} else {
					pluginsToLoad.push({ p });
				}
			}
		}

		pluginsToLoad.sort((a, b) => (a.p.sort ?? 100) - (b.p.sort ?? 100));

		for (const item of pluginsToLoad) {
			this.plugin(item.p, item.o);
		}
	}

	public plugin<KirePlugged extends KirePlugin<any>>(
		plugin: KirePlugged,
		opts?: KirePlugged["options"],
	) {
		if (typeof plugin === "function") {
			(plugin as any)(this, opts);
		} else if (plugin.load) {
			plugin.load(this, opts);
		}
		return this;
	}

	public pkgSchema(
		name: string,
		repository?: string | { type: string; url: string },
		version?: string,
	): KireSchematic {
		const globals: Record<string, any> = {};
		this.$globals.forEach((value, key) => {
			globals[key] = value;
		});

		return {
			package: name,
			repository,
			version,
			directives: Array.from(this.$directives.values()),
			elements: Array.from(this.$elements.values()),
			globals: globals,
		};
	}

	public element(
		nameOrDef: string | RegExp | ElementDefinition,
		handler?: KireElementHandler,
		options?: KireElementOptions,
	) {
		if (
			typeof nameOrDef === "object" &&
			"onCall" in nameOrDef &&
			!("source" in nameOrDef)
		) {
			this.$elements.add(nameOrDef as ElementDefinition);
		} else {
			if (!handler) throw new Error("Handler is required for legacy element()")
			this.$elements.add({
				name: nameOrDef as string | RegExp,
				void: options?.void,
				onCall: handler,
			});
		}
		return this;
	}

	public directive(def: DirectiveDefinition) {
		this.$directives.set(def.name, def);
		if (def.parents) {
			for (const parent of def.parents) {
				this.directive(parent);
			}
		}
		return this;
	}

	public getDirective(name: string) {
		return this.$directives.get(name);
	}

	public $ctx(key: string, value: any) {
		this.$globals.set(key, value);
		return this;
	}

	public parse(template: string) {
		const parser = new this.$parser(template, this);
		return parser.parse();
	}

	public async compile(template: string): Promise<string> {
		const parser = new this.$parser(template, this);
		const nodes = parser.parse();
		const compiler = new this.$compiler(this);
		return compiler.compile(nodes);
	}

	public async compileFn(content: string): Promise<Function> {
		const code = await this.compile(content);
		try {
			const AsyncFunction = Object.getPrototypeOf(async () => { }).constructor;

			const mainFn = new AsyncFunction("$ctx", code);

			// Return the separated functions
			return mainFn;
		} catch (e) {
			console.error("Error creating function from code:", code);
			throw e;
		}
	}

	public async render(
		template: string,
		locals: Record<string, any> = {},
	): Promise<string> {
		const fn = await this.compileFn(template);
		return this.run(fn, locals);
	}

	public async view(
		path: string,
		locals: Record<string, any> = {},
	): Promise<string> {
		const resolvedPath = resolvePath(path, this.root, this.alias, this.extension);
		let compiled: Function | undefined;

		if (this.production && this.$files.has(resolvedPath)) {
			compiled = this.$files.get(resolvedPath) as any;
		} else {
			try {
				const content = await this.$resolver(resolvedPath);
				compiled = await this.compileFn(content);
				if (this.production) {
					this.$files.set(resolvedPath, compiled as any);
				}
			} catch (e) {
				throw e;
			}
		}

		if (!compiled) throw new Error(`Could not load view: ${path}`);
		return this.run(compiled, locals);
	}

	public resolvePath(
		filepath: string,
		currentFile?: string,
	): string {
		return resolvePath(filepath, this.root, this.alias, this.extension, currentFile);
	}

	private async run(mainFn: Function, locals: Record<string, any>): Promise<string> {
		const rctx: any = {};
		for (const [k, v] of this.$globals) {
			rctx[k] = v;
		}
		Object.assign(rctx, locals);

		if (this.$expose_locals) {
			rctx[this.$var_locals] = locals;
		}

		rctx['~res'] = "";
		rctx['~$pre'] = [];
		rctx['~$pos'] = [];

		rctx.res = function (this: any, str: any) {
			rctx['~res'] += str;
		};

		rctx.$res = () => rctx['~res'];

		rctx.$resolve = (path: string) => {
			return this.resolvePath(path);
		};

		rctx.$merge = async function (this: any, func: Function) {
			const parentRes = this['~res'];
			this['~res'] = "";
			await func(this);
			this['~res'] = parentRes + this['~res'];
		};

		const finalCtx = await mainFn(rctx);

		// Execute ~$pre functions collected during execution
		if (finalCtx['~$pre'] && finalCtx['~$pre'].length > 0) {
			for (const preFn of finalCtx['~$pre']) {
				await preFn(rctx);
			}
		}

		let resultHtml = finalCtx['~res'];
		
		// Execute ~$pos functions (deferred logic)
		if (finalCtx['~$pos'] && finalCtx['~$pos'].length > 0) {
			for (const posFn of finalCtx['~$pos']) {
				await posFn(rctx);
			}
			resultHtml = finalCtx['~res'];
		}

		if (this.$elements.size > 0) {
			for (const def of this.$elements) {
				const tagName =
					def.name instanceof RegExp ? def.name.source : def.name;

				const isVoid =
					def.void ||
					(typeof def.name === "string" &&
						/^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/i.test(
							def.name,
						));

				const regex = isVoid
					? new RegExp(`<(${tagName})([^>]*)>`, "gi")
					: new RegExp(
						`<(${tagName})([^>]*)>([\s\S]*?)<\/\\1>`,
						"gi",
					);

				const matches = [];
				let match;
				while ((match = regex.exec(resultHtml)) !== null) {
					matches.push({
						full: match[0],
						tagName: match[1],
						attrs: match[2],
						inner: isVoid ? "" : match[3],
						index: match.index,
					});
				}

				for (const m of matches) {
					if (!resultHtml.includes(m.full)) {
						continue;
					}

					const attributes: Record<string, string> = {};
					const attrRegex = /(\w+)="([^"]*)"/g;
					let attrMatch;
					while ((attrMatch = attrRegex.exec(m.attrs!)) !== null) {
						attributes[attrMatch[1]!] = attrMatch[2]!;
					}

					const elCtx: any = Object.create(rctx);
					elCtx.content = resultHtml;
					elCtx.element = {
						tagName: m.tagName,
						attributes,
						inner: m.inner,
						outer: m.full,
					};
					elCtx.update = (newContent: string) => {
						resultHtml = newContent;
						elCtx.content = newContent;
					};
					elCtx.replace = (replacement: string) => {
						resultHtml = resultHtml.replace(m.full, replacement);
						elCtx.content = resultHtml;
					};
					elCtx.replaceContent = (replacement: string) => {
						if (!isVoid) {
							const newOuter = m.full.replace(m.inner!, replacement);
							resultHtml = resultHtml.replace(m.full, newOuter);
							elCtx.content = resultHtml;
						}
					};

					await def.onCall(elCtx);

					if (elCtx.content !== resultHtml) {
						resultHtml = elCtx.content;
					}
				}
			}
		}

		return resultHtml;
	}
}

// --- From: core/src/index.ts ---
export * from "./compiler";
export * from "./kire";
export * from "./parser";
export * from "./types";


// --- From: core/src/directives/import.ts ---
import type { Kire } from "../kire";

export default (kire: Kire) => {
	kire.directive({
		name: "include",
		params: ["path:string", "locals:object"],
		children: false,
		type: "html",
		description:
			"Includes and renders a template from a given path, optionally passing local variables.",
		example: `@include('partials/card')`,
		onCall(ctx) {
			const pathExpr = ctx.param("path");
			const localsExpr = ctx.param("locals") || "{}";

			ctx.raw(`await $ctx.$merge(async ($ctx) => {
    const path = $ctx.resolve(${JSON.stringify(pathExpr)});
    const locals = ${localsExpr};
    const templateFn = await $ctx.require(path, $ctx, locals);
    
    if (templateFn) {
        Object.assign($ctx, locals);
        if(${JSON.stringify(kire.exposeLocals)}) $ctx[${JSON.stringify(kire.varLocals)}] = locals;
        
        await templateFn($ctx);
    }
});`);
		},
	});
};

// --- From: core/src/directives/natives.ts ---
import type { Kire } from "../kire";

export default (kire: Kire) => {
	kire.directive({
		name: "if",
		params: ["cond:string"],
		children: true,
		type: "js",
		description:
			"Conditionally renders a block of content if the expression is true.",
		example: `@if(user.isLoggedIn)\n  Welcome, {{ user.name }}!\n@end`,
		parents: [
			{
				name: "elseif",
				params: ["cond:string"],
				children: true,
				type: "js",
				description:
					"Renders a block of content if the preceding @if/@elseif is false and the current expression is true.",
				example: `@elseif(user.isAdmin)\n  Admin access granted.\n@end`,
				async onCall(c) {
					c.raw(`} else if (${c.param("cond")}) {`);
					if (c.children) await c.set(c.children);
				},
			},
			{
				name: "elif", // alias for elseif
				params: ["cond:string"],
				children: true,
				type: "js",
				description: "Alias for @elseif.",
				example: `@elif(user.isAdmin)\n  Admin access granted.\n@end`,
				async onCall(c) {
					c.raw(`} else if (${c.param("cond")}) {`);
					if (c.children) await c.set(c.children);
				},
			},
			{
				name: "else",
				children: true,
				type: "js",
				description:
					"Renders a block of content if the preceding @if/@elseif expressions are all false.",
				example: `@else\n  Please log in.\n@end`,
				async onCall(c) {
					c.raw(`} else {`);
					if (c.children) await c.set(c.children);
				},
			},
		],
		async onCall(ctx) {
			ctx.raw(`if (${ctx.param("cond")}) {`);
			if (ctx.children) await ctx.set(ctx.children);
			if (ctx.parents) await ctx.set(ctx.parents);
			ctx.raw("}");
		},
	});

	kire.directive({
		name: "for",
		params: ["expr:string"],
		children: true,
		type: "js",
		description:
			"Iterates over an array or object, similar to a JavaScript for...of loop.",
		example: `@for(user of users)\n  <p>{{ user.name }}</p>\n@end`,
		async onCall(ctx) {
			const expr = ctx.param("expr");
			if (expr.includes(" in ")) {
				const [lhs, rhs] = expr.split(" in ");
				ctx.raw(`for (const ${lhs.trim()} in ${rhs.trim()}) {`);
			} else if (expr.includes(" of ")) {
				const [lhs, rhs] = expr.split(" of ");
				ctx.raw(`for (const ${lhs.trim()} of ${rhs.trim()}) {`);
			} else {
				ctx.raw(`for (${expr}) {`);
			}

			if (ctx.children) await ctx.set(ctx.children);
			ctx.raw(`}`);
		},
	});

	kire.directive({
		name: "const",
		params: ["expr:string"],
		type: "js",
		description:
			"Declares a block-scoped constant, similar to JavaScript `const`.",
		example: `@const(myVar = 'hello world')`,
		onCall(ctx) {
			ctx.raw(`const ${ctx.param("expr")};`);
		},
	});

	kire.directive({
		name: "let",
		params: ["expr:string"],
		type: "js",
		description:
			"Declares a block-scoped local variable, similar to JavaScript `let`.",
		example: `@let(counter = 0)`,
		onCall(ctx) {
			ctx.raw(`let ${ctx.param("expr")};`);
		},
	});

	kire.directive({
		name: "code",
		children: true,
		type: "js",
		description: "Executes a block of raw JavaScript code on the server.",
		example: `@code\n  console.log('This runs during template compilation.');\n@end`,
		onCall(ctx) {
			if (ctx.children) {
				for (const child of ctx.children) {
					if (child.type === "text" && child.content) {
						ctx.raw(child.content);
					}
				}
			}
		},
	});

	kire.directive({
		name: "switch",
		params: ["expr:string"],
		children: true,
		type: "js",
		description:
			"Provides a control flow statement similar to a JavaScript switch block.",
		example: `@switch(value)\n  @case(1) ... @end\n  @default ... @end\n@end`,
		parents: [
			{
				name: "case",
				params: ["val:string"],
				children: true,
				type: "js",
				description: "A case clause for a @switch statement.",
				example: `@case('A')\n  <p>Value is A</p>\n@end`,
				async onCall(c) {
					c.raw(`case ${JSON.stringify(c.param("val"))}: {`);
					if (c.children) await c.set(c.children);
					c.raw(`break; }`);
				},
			},
			{
				name: "default",
				children: true,
				type: "js",
				description: "The default clause for a @switch statement.",
				example: `@default\n  <p>Value is something else</p>\n@end`,
				async onCall(c) {
					c.raw(`default: {`);
					if (c.children) await c.set(c.children);
					c.raw(`}`);
				},
			},
		],
		async onCall(ctx) {
			ctx.raw(`switch (${ctx.param("expr")}) {`);
			if (ctx.parents) await ctx.set(ctx.parents);
			ctx.raw(`}`);
		},
	});
};


// --- From: core/src/directives/component.ts ---
import type { Kire } from "../kire";

export default (kire: Kire) => {
	// @component('path', {vars}) ... @end
	// Uses slots.

	kire.directive({
		name: "slot",
		params: ["name:string"],
		children: true,
		type: "html",
		description: "Defines a named content slot within a component.",
		example: `@slot('header')\n  <h1>This is the header</h1>\n@end`,
		onCall(c) {
			const name = c.param("name");
			c.raw(`await $ctx.$merge(async ($ctx) => {`);
			if (c.children) c.set(c.children);
			c.raw(`  $slots[${JSON.stringify(name)}] = $ctx['~res'];`);
			c.raw(`  $ctx['~res'] = '';`);
			c.raw(`});`);
		},
	});

	kire.directive({
		name: "component",
		params: ["path:string", "variables:object"],
		children: true,
		type: "html",
		description:
			"Loads a template as a reusable component, allowing content to be passed into named slots.",
		example: `@component('card', { title: 'My Card' })\n  @slot('header')\n    <h1>Card Header</h1>\n  @end\n  <p>Default content.</p>\n@end`,
		async onCall(ctx) {
			const pathExpr = ctx.param("path");
			const varsExpr = ctx.param("variables") || "{}";

			ctx.raw(`await (async () => {`);
			ctx.raw(`  const $slots = {};`);

			// Run children to populate slots
			ctx.raw(`  await $ctx.$merge(async ($ctx) => {`);
			// Inject $slots into scope for @slot to access
			// But wait, @slot uses $slots from closure scope if defined in `component` block.
			// `const $slots = {}` is in the `await (async () => {` block.
			// @slot runs inside `$ctx.$merge`.
			// The closure scope is preserved.
			// But we need to make sure `default` slot is captured correctly.
			// Default slot is whatever is output by children (excluding what @slot captures/clears).
			// @slot clears its output. So `~res` will contain only non-slot content.
			
			// We need to expose `$slots` to children if they need it? No, @slot uses it from parent scope.
			// But wait, `slot` directive code `c.raw` will be emitted inside `component` body code.
			// So `$slots` variable is available.
			
			// However, `component` used `$bodyCtx.slots = $slots`.
			// If we remove `$bodyCtx`, we rely on closure variable `$slots`.
			
			ctx.raw(`    $ctx.slots = $slots;`); // Should we attach to ctx? Maybe for nested access?
			
			if (ctx.children) await ctx.set(ctx.children);

			ctx.raw(`    if (!$slots.default) $slots.default = $ctx['~res'];`);
			ctx.raw(`    $ctx['~res'] = '';`); // Clear default content from parent stream
			ctx.raw(`  });`);

			// Now load the component template
			ctx.raw(`  const path = $ctx.resolve(${JSON.stringify(pathExpr)});`);
			ctx.raw(`  const locals = ${varsExpr};`);
			ctx.raw(`  const templateFn = await $ctx.require(path, $ctx, locals);`);
			ctx.raw(`  if (templateFn) {`);
			
			// Render component template
			// We use $merge to capture output or just run it?
			// Component output SHOULD be rendered to parent stream.
			// But we need isolated scope for locals?
			// "remover o const child = { ...this }".
			// So we use global context + $merge (which handles res buffer).
			// We assign locals to global context?
			
			ctx.raw(`    await $ctx.$merge(async ($ctx) => {`);
			ctx.raw(`      Object.assign($ctx, locals);`);
			ctx.raw(`      $ctx[${JSON.stringify(kire.varLocals)}] = locals;`);
			ctx.raw(`      if(typeof locals === 'object' && locals !== null) locals.slots = $slots;`);
			ctx.raw(`      $ctx.slots = $slots;`);
			
			ctx.raw(`      await templateFn($ctx);`);
			ctx.raw(`    });`);
			
			ctx.raw(`  }`);

			ctx.raw(`})();`);
		},
	});
};

// --- From: core/src/directives/layout.ts ---
import type { Kire } from "../kire";
import type { KireContext } from "../types";

export default (kire: Kire) => {
	// Initialize global defines object via runtime checks, not kire.$ctx
	
kire.directive({
		name: "define",
		params: ["name:string"],
		children: true,
		type: "html",
		description:
			"Defines a named, reusable section of content that can be rendered elsewhere.",
		example: `@define('header')\n  <h1>My Website</h1>\n@end`,
		async onCall(ctx) {
			const name = ctx.param("name");

			ctx.raw(`if(!$ctx['~defines']) $ctx['~defines'] = {};`);
			ctx.raw(`await $ctx.$merge(async ($ctx) => {`);

			if (ctx.children) await ctx.set(ctx.children);

			ctx.raw(`  $ctx['~defines'][${JSON.stringify(name)}] = $ctx['~res'];`);
			ctx.raw(`  $ctx['~res'] = '';`);
			ctx.raw(`});`);
		},
	});

	kire.directive({
		name: "defined",
		params: ["name:string"],
		type: "html",
		description: "Renders a content section previously created with @define.",
		example: `@defined('header')`,
		onCall(ctx) {
			const name = ctx.param("name");

			ctx.raw(
				`$ctx.res("<!-- KIRE:defined(" + ${JSON.stringify(name)} + ") -->");`
			);
		},
		once(ctx) {
			ctx.$pre(`if(!$ctx['~defines']) $ctx['~defines'] = {};`);
			ctx.$pos(`
                // Post-process defined placeholders
                if ($ctx['~defines']) {
                    for (const key in $ctx['~defines']) {
                        const placeholder = "<!-- KIRE:defined(" + key + ") -->";
                        if ($ctx['~res'].includes(placeholder)) {
                             $ctx['~res'] = $ctx['~res'].split(placeholder).join($ctx['~defines'][key]);
                        }
                    }
                    // Cleanup unmatched placeholders?
                    $ctx['~res'] = $ctx['~res'].replace(/<!-- KIRE:defined\\(.*?\\) -->/g, '');
                }
            `);
		}
	});

	kire.directive({
		name: "stack",
		params: ["name:string"],
		type: "html",
		description:
			"Creates a placeholder where content pushed to a named stack will be rendered.",
		example: `<html>\n<head>\n  @stack('scripts')\n</head>\n</html>`,
		onCall(ctx) {
			const name = ctx.param("name");
			ctx.raw(
				`$ctx.res("<!-- KIRE:stack(" + ${JSON.stringify(name)} + ") -->");`
			);
		},
		once(ctx) {
			ctx.$pre(`if(!$ctx['~stacks']) $ctx['~stacks'] = {};`);
			ctx.$pos(`
                if ($ctx['~stacks']) {
                    for (const key in $ctx['~stacks']) {
                         const placeholder = "<!-- KIRE:stack(" + key + ") -->";
                         if ($ctx['~res'].includes(placeholder)) {
                              const content = $ctx['~stacks'][key].join('\\n');
                              $ctx['~res'] = $ctx['~res'].split(placeholder).join(content);
                         }
                    }
                    $ctx['~res'] = $ctx['~res'].replace(/<!-- KIRE:stack\\(.*?\\) -->/g, '');
                }
             `);
		}
	});

	kire.directive({
		name: "push",
		params: ["name:string"],
		children: true,
		type: "html",
		description: "Pushes a block of content onto a named stack.",
		example: `@push('scripts')\n  <script src="app.js"></script>\n@end`,
		async onCall(ctx: KireContext) {
			const name = ctx.param("name");
			ctx.raw(`if(!$ctx['~stacks']) $ctx['~stacks'] = {};`);
			ctx.raw(
				`if (!$ctx['~stacks'][${JSON.stringify(name)}]) $ctx['~stacks'][${JSON.stringify(name)}] = [];`
			);
			ctx.raw(
				`await $ctx.$merge(async ($ctx) => {`
			);

			if (ctx.children) await ctx.set(ctx.children);

			ctx.raw(`  $ctx['~stacks'][${JSON.stringify(name)}].push($ctx['~res']);`);
			ctx.raw(`  $ctx['~res'] = '';`);
			ctx.raw(`});`);
		},
	});
};

// --- From: core/src/directives/index.ts ---
import type { KirePlugin } from "../types";
import componentDirectives from "./component";
import importDirectives from "./import";
import defineDirectives from "./layout";
import nativeDirectives from "./natives";

export const KireDirectives: KirePlugin = {
	name: "kire",
	sort: 100,
	options: {},
	load(kire) {
		defineDirectives(kire);
		nativeDirectives(kire);
		importDirectives(kire);
		componentDirectives(kire);
	},
};


// --- From: core/src/compiler/index.ts ---
import type { Kire } from "../kire";
import type { KireContext, Node } from "../types";

export class Compiler {
	private preBuffer: string[] = [];
	private resBuffer: string[] = [];
	private posBuffer: string[] = [];
	// Removed gPreBuffer and gPosBuffer

	private usedDirectives: Set<string> = new Set();

	constructor(private kire: Kire) {}

	public async compile(nodes: Node[]): Promise<string> {
		this.preBuffer = [];
		this.resBuffer = [];
		this.posBuffer = [];
		// Removed gPreBuffer and gPosBuffer init
		this.usedDirectives.clear();

		// Compile the root nodes
		await this.compileNodes(nodes);

		// gPre and gPos are now collected at runtime via generated code
		const pre = this.preBuffer.join("\n");
		const res = this.resBuffer.join("\n");
		const pos = this.posBuffer.join("\n");

		// Main function body code
		const code = `with($ctx) { \n${pre}\n${res}\n${pos}\nreturn $ctx;\n }`;

		return code;
	}

	private async compileNodes(nodes: Node[]) {
		let i = 0;
		while (i < nodes.length) {
			const node = nodes[i]!;
			if (node.type === "text") {
				if (node.content) {
					this.resBuffer.push(
						`$ctx['~res'] += ${JSON.stringify(node.content)};`,
					);
				}
			} else if (node.type === "variable") {
				if (node.content) {
					// Simple interpolation
					this.resBuffer.push(
						`$ctx['~res'] += (${node.content});`,
					);
				}
			} else if (node.type === "directive") {
				await this.processDirective(node);
			}
			i++;
		}
	}

	private async processDirective(node: Node) {
		const name = node.name;
		if (!name) return;

		// Check if directive exists in Kire instance
		const directive = this.kire.getDirective(name);

		if (!directive) {
			// Handle unknown directive
			console.warn(`Directive @${name} not found.`);
			return;
		}

		const ctx: KireContext = {
			param: (key: string | number) => {
				if (typeof key === "number") {
					return node.args?.[key];
				}
				if (directive.params && node.args) {
					const index = directive.params.findIndex(
						(p) => p.split(":")[0] === key,
					);
					if (index !== -1) return node.args[index];
				}
				return undefined;
			},
			children: node.children,
			parents: node.related, // 'parents' in user logic map to 'related' nodes from parser
			set: async (nodes: Node[]) => {
				if (!nodes) return;
				await this.compileNodes(nodes);
			},
			render: async (content: string) => {
				// This needs to return the object {code, gPre, gPos}
				// But compile expects string for now.
				return (await this.kire.compile(content)); 
			},
			resolve: (path: string) => {
				return this.kire.resolvePath(path);
			},
			func: (code: string) => {
				return `async function($ctx) { ${code} }`;
			},
			pre: (code: string) => {
				this.preBuffer.push(code);
			},
			res: (content: string) => {
				const escaped = content
					.replace(/\\/g, "\\\\")
					.replace(/`/g, "\\`")
					.replace(/\${/g, "\\${ ");
				this.resBuffer.push(`$ctx.res(${escaped}\n");`);
			},
			raw: (code: string) => {
				this.resBuffer.push(code);
			},
			pos: (code: string) => {
				this.posBuffer.push(code);
			},
			$pre: (code: string) => {
				this.resBuffer.push(`$ctx['~$pre'].push(async ($ctx) => { with($ctx) { ${code} } });`);
			},
			$pos: (code: string) => {
				this.resBuffer.push(`$ctx['~$pos'].push(async ($ctx) => { with($ctx) { ${code} } });`);
			},
			error: (msg: string) => {
				throw new Error(`Error in directive @${name}: ${msg}`);
			},
		};

		if (directive.once && !this.usedDirectives.has(name)) {
			this.usedDirectives.add(name);
			await directive.once(ctx);
		}

		await directive.onCall(ctx);
	}
}

// --- From: core/src/utils/resolve.ts ---
import { join } from "./path";

export function resolvePath(
	filepath: string,
	root: string,
	alias: Record<string, string>,
	extension?: string,
	currentFile?: string,
): string {
	if (!filepath) return filepath;

	if (filepath.startsWith("http://") || filepath.startsWith("https://")) {
		return filepath;
	}

	let resolved = filepath.replace(/\\/g, "/").replace(/(?<!:)\/+/g, "/");
	const normalizedRoot = root.replace(/\\/g, "/").replace(/\/\/$/, "");

	const isWindowsAbsolute = /^[a-zA-Z]:\/$/.test(resolved);

	const aliases = Object.entries(alias);
	aliases.sort((a, b) => b[0].length - a[0].length);

	let matchedAlias = false;
	for (const [aliasKey, replacement] of aliases) {
		const escapedAlias = aliasKey.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
		if (new RegExp(`^${escapedAlias}`).test(filepath)) {
			resolved = join(replacement, filepath.slice(aliasKey.length));
			matchedAlias = true;
			break;
		}
	}

	if (matchedAlias) {
		// handled
	} else {
		const isResolvedAbsolute = /^(?:\/|[a-zA-Z]:\/)/.test(resolved);
		if (!isResolvedAbsolute && !isWindowsAbsolute) {
			const base = currentFile
				? currentFile.replace(/\\/g, "/").replace(/\/[^/]*$/, "")
				: normalizedRoot;
			resolved = join(base, resolved);
		}
	}

	if (
		extension &&
		!/\.[^/.]+$/.test(resolved) &&
		!(resolved.startsWith("http://") || resolved.startsWith("https://"))
	) {
		const ext = extension.charAt(0) === "." ? extension : `.${extension}`;
		resolved += ext;
	}

	return resolved.replace(/\/+/g, "/");
}


// --- From: core/src/utils/path.ts ---
/**
 * Joins path segments and normalizes the resulting path
 */
export function join(...segments: string[]): string {
	if (!segments.length) return ".";

	const windowsAbsoluteRegex = /^[a-zA-Z]:[\\/]/;
	const isWindowsAbsolute = segments.some((s) => windowsAbsoluteRegex.test(s));
	const driveLetter = isWindowsAbsolute
		? segments
				.find((s) => windowsAbsoluteRegex.test(s))
				?.charAt(0)
				.toUpperCase()
		: null;

	// Normalize all segments at once
	const normalized = segments
		.join("/")
		.replace(/\\/g, "/")
		.replace(/\/+/g, "/");
	const isAbsolute = /^(?:\/|[a-zA-Z]:\/)/.test(normalized);

	const parts = normalized.split("/");
	const result: string[] = [];
	let i = 0;

	while (i < parts.length) {
		const part = parts[i++];
		if (!part || part === ".") continue;

		if (part === "..") {
			if (result.length && result[result.length - 1] !== "..") {
				result.pop();
			} else {
				result.push(part);
			}
		} else {
			result.push(part);
		}
	}

	let path = result.join("/");

	if (isWindowsAbsolute && driveLetter) {
		path = path.replace(/^[a-zA-Z]:/, "").replace(/^\//, "");
		path = `${driveLetter}:\\${path.replace(/\//g, "\\")}`.replace(
			/\\+/g,
			"\\",
		);
		return path || ".";
	}

	return isAbsolute ? `/${path.replace(/^\//, "")}` : path || ".";
}


// --- From: core/src/utils/md5.ts ---

export function md5(string: string): string {
	function rotateLeft(lValue: number, iShiftBits: number): number {
		return (lValue << iShiftBits) | (lValue >>> (32 - iShiftBits));
	}

	function addUnsigned(lX: number, lY: number): number {
		const lX8 = lX & 0x80000000;
		const lY8 = lY & 0x80000000;
		const lX4 = lX & 0x40000000;
		const lY4 = lY & 0x40000000;
		const lResult = (lX & 0x3fffffff) + (lY & 0x3fffffff);
		if (lX4 & lY4) {
			return lResult ^ 0x80000000 ^ lX8 ^ lY8;
		}
		if (lX4 | lY4) {
			if (lResult & 0x40000000) {
				return lResult ^ 0xc0000000 ^ lX8 ^ lY8;
			} else {
				return lResult ^ 0x40000000 ^ lX8 ^ lY8;
			}
		} else {
			return lResult ^ lX8 ^ lY8;
		}
	}

	function F(x: number, y: number, z: number): number {
		return (x & y) | (~x & z);
	}
	function G(x: number, y: number, z: number): number {
		return (x & z) | (y & ~z);
	}
	function H(x: number, y: number, z: number): number {
		return x ^ y ^ z;
	}
	function I(x: number, y: number, z: number): number {
		return y ^ (x | ~z);
	}

	function FF(
		a: number,
		b: number,
		c: number,
		d: number,
		x: number,
		s: number,
		ac: number,
	): number {
		a = addUnsigned(a, addUnsigned(addUnsigned(F(b, c, d), x), ac));
		return addUnsigned(rotateLeft(a, s), b);
	}

	function GG(
		a: number,
		b: number,
		c: number,
		d: number,
		x: number,
		s: number,
		ac: number,
	): number {
		a = addUnsigned(a, addUnsigned(addUnsigned(G(b, c, d), x), ac));
		return addUnsigned(rotateLeft(a, s), b);
	}

	function HH(
		a: number,
		b: number,
		c: number,
		d: number,
		x: number,
		s: number,
		ac: number,
	): number {
		a = addUnsigned(a, addUnsigned(addUnsigned(H(b, c, d), x), ac));
		return addUnsigned(rotateLeft(a, s), b);
	}

	function II(
		a: number,
		b: number,
		c: number,
		d: number,
		x: number,
		s: number,
		ac: number,
	): number {
		a = addUnsigned(a, addUnsigned(addUnsigned(I(b, c, d), x), ac));
		return addUnsigned(rotateLeft(a, s), b);
	}

	function convertToWordArray(string: string): number[] {
		let lWordCount;
		const lMessageLength = string.length;
		const lNumberOfWords_temp1 = lMessageLength + 8;
		const lNumberOfWords_temp2 =
			(lNumberOfWords_temp1 - (lNumberOfWords_temp1 % 64)) / 64;
		const lNumberOfWords = (lNumberOfWords_temp2 + 1) * 16;
		const lWordArray = Array(lNumberOfWords - 1);
		let lBytePosition = 0;
		let lByteCount = 0;
		while (lByteCount < lMessageLength) {
			lWordCount = (lByteCount - (lByteCount % 4)) / 4;
			lBytePosition = (lByteCount % 4) * 8;
			lWordArray[lWordCount] =
				(lWordArray[lWordCount] || 0) |
				(string.charCodeAt(lByteCount) << lBytePosition);
			lByteCount++;
		}
		lWordCount = (lByteCount - (lByteCount % 4)) / 4;
		lBytePosition = (lByteCount % 4) * 8;
		lWordArray[lWordCount] = (lWordArray[lWordCount] || 0) | (0x80 << lBytePosition);
		lWordArray[lNumberOfWords - 2] = lMessageLength << 3;
		lWordArray[lNumberOfWords - 1] = lMessageLength >>> 29;
		
		// Ensure no undefined holes
		for(let i=0; i<lWordArray.length; i++) {
			if(lWordArray[i] === undefined) lWordArray[i] = 0;
		}
		return lWordArray;
	}

	function wordToHex(lValue: number): string {
		let WordToHexValue = "";
		let WordToHexValue_temp = "";
		for (let lCount = 0; lCount <= 3; lCount++) {
			const lByte = (lValue >>> (lCount * 8)) & 255;
			WordToHexValue_temp = `0${lByte.toString(16)}`;
			WordToHexValue =
				WordToHexValue +
				WordToHexValue_temp.substr(WordToHexValue_temp.length - 2, 2);
		}
		return WordToHexValue;
	}

	let x: number[] = [];
	let k: number = 0, 
		AA: number = 0, 
		BB: number = 0, 
		CC: number = 0, 
		DD: number = 0, 
		a: number = 0, 
		b: number = 0, 
		c: number = 0, 
		d: number = 0;
	const S11 = 7,
		S12 = 12,
		S13 = 17,
		S14 = 22;
	const S21 = 5,
		S22 = 9,
		S23 = 14,
		S24 = 20;
	const S31 = 4,
		S32 = 11,
		S33 = 16,
		S34 = 23;
	const S41 = 6,
		S42 = 10,
		S43 = 15,
		S44 = 21;

	x = convertToWordArray(string);
	a = 0x67452301;
	b = 0xefcdab89;
	c = 0x98badcfe;
	d = 0x10325476;

	for (k = 0; k < x.length; k += 16) {
		AA = a;
		BB = b;
		CC = c;
		DD = d;
		a = FF(a, b, c, d, x[k + 0] || 0, S11, 0xd76aa478);
		d = FF(d, a, b, c, x[k + 1] || 0, S12, 0xe8c7b756);
		c = FF(c, d, a, b, x[k + 2] || 0, S13, 0x242070db);
		b = FF(b, c, d, a, x[k + 3] || 0, S14, 0xc1bdceee);
		a = FF(a, b, c, d, x[k + 4] || 0, S11, 0xf57c0faf);
		d = FF(d, a, b, c, x[k + 5] || 0, S12, 0x4787c62a);
		c = FF(c, d, a, b, x[k + 6] || 0, S13, 0xa8304613);
		b = FF(b, c, d, a, x[k + 7] || 0, S14, 0xfd469501);
		a = FF(a, b, c, d, x[k + 8] || 0, S11, 0x698098d8);
		d = FF(d, a, b, c, x[k + 9] || 0, S12, 0x8b44f7af);
		c = FF(c, d, a, b, x[k + 10] || 0, S13, 0xffff5bb1);
		b = FF(b, c, d, a, x[k + 11] || 0, S14, 0x895cd7be);
		a = FF(a, b, c, d, x[k + 12] || 0, S11, 0x6b901122);
		d = FF(d, a, b, c, x[k + 13] || 0, S12, 0xfd987193);
		c = FF(c, d, a, b, x[k + 14] || 0, S13, 0xa679438e);
		b = FF(b, c, d, a, x[k + 15] || 0, S14, 0x49b40821);
		a = GG(a, b, c, d, x[k + 1] || 0, S21, 0xf61e2562);
		d = GG(d, a, b, c, x[k + 6] || 0, S22, 0xc040b340);
		c = GG(c, d, a, b, x[k + 11] || 0, S23, 0x265e5a51);
		b = GG(b, c, d, a, x[k + 0] || 0, S24, 0xe9b6c7aa);
		a = GG(a, b, c, d, x[k + 5] || 0, S21, 0xd62f105d);
		d = GG(d, a, b, c, x[k + 10] || 0, S22, 0x02441453);
		c = GG(c, d, a, b, x[k + 15] || 0, S23, 0xd8a1e681);
		b = GG(b, c, d, a, x[k + 4] || 0, S24, 0xe7d3fbc8);
		a = GG(a, b, c, d, x[k + 9] || 0, S21, 0x21e1cde6);
		d = GG(d, a, b, c, x[k + 14] || 0, S22, 0xc33707d6);
		c = GG(c, d, a, b, x[k + 3] || 0, S23, 0xf4d50d87);
		b = GG(b, c, d, a, x[k + 8] || 0, S24, 0x455a14ed);
		a = GG(a, b, c, d, x[k + 13] || 0, S21, 0xa9e3e905);
		d = GG(d, a, b, c, x[k + 2] || 0, S22, 0xfcefa3f8);
		c = GG(c, d, a, b, x[k + 7] || 0, S23, 0x676f02d9);
		b = GG(b, c, d, a, x[k + 12] || 0, S24, 0x8d2a4c8a);
		a = HH(a, b, c, d, x[k + 5] || 0, S31, 0xfffa3942);
		d = HH(d, a, b, c, x[k + 8] || 0, S32, 0x8771f681);
		c = HH(c, d, a, b, x[k + 11] || 0, S33, 0x6d9d6122);
		b = HH(b, c, d, a, x[k + 14] || 0, S34, 0xfde5380c);
		a = HH(a, b, c, d, x[k + 1] || 0, S31, 0xa4beea44);
		d = HH(d, a, b, c, x[k + 4] || 0, S32, 0x4bdecfa9);
		c = HH(c, d, a, b, x[k + 7] || 0, S33, 0xf6bb4b60);
		b = HH(b, c, d, a, x[k + 10] || 0, S34, 0xbebfbc70);
		a = HH(a, b, c, d, x[k + 13] || 0, S31, 0x289b7ec6);
		d = HH(d, a, b, c, x[k + 0] || 0, S32, 0xeaa127fa);
		c = HH(c, d, a, b, x[k + 3] || 0, S33, 0xd4ef3085);
		b = HH(b, c, d, a, x[k + 6] || 0, S34, 0x04881d05);
		a = HH(a, b, c, d, x[k + 9] || 0, S31, 0xd9d4d039);
		d = HH(d, a, b, c, x[k + 12] || 0, S32, 0xe6db99e5);
		c = HH(c, d, a, b, x[k + 15] || 0, S33, 0x1fa27cf8);
		b = HH(b, c, d, a, x[k + 2] || 0, S34, 0xc4ac5665);
		a = II(a, b, c, d, x[k + 0] || 0, S41, 0xf4292244);
		d = II(d, a, b, c, x[k + 7] || 0, S42, 0x432aff97);
		c = II(c, d, a, b, x[k + 14] || 0, S43, 0xab9423a7);
		b = II(b, c, d, a, x[k + 5] || 0, S44, 0xfc93a039);
		a = II(a, b, c, d, x[k + 12] || 0, S41, 0x655b59c3);
		d = II(d, a, b, c, x[k + 3] || 0, S42, 0x8f0ccc92);
		c = II(c, d, a, b, x[k + 10] || 0, S43, 0xffeff47d);
		b = II(b, c, d, a, x[k + 1] || 0, S44, 0x85845dd1);
		a = II(a, b, c, d, x[k + 8] || 0, S41, 0x6fa87e4f);
		d = II(d, a, b, c, x[k + 15] || 0, S42, 0xfe2ce6e0);
		c = II(c, d, a, b, x[k + 6] || 0, S43, 0xa3014314);
		b = II(b, c, d, a, x[k + 13] || 0, S44, 0x4e0811a1);
		a = II(a, b, c, d, x[k + 4] || 0, S41, 0xf7537e82);
		d = II(d, a, b, c, x[k + 11] || 0, S42, 0xbd3af235);
		c = II(c, d, a, b, x[k + 2] || 0, S43, 0x2ad7d2bb);
		b = II(b, c, d, a, x[k + 9] || 0, S44, 0xeb86d391);
		a = addUnsigned(a, AA);
		b = addUnsigned(b, BB);
		c = addUnsigned(c, CC);
		d = addUnsigned(d, DD);
	}
	const temp = wordToHex(a) + wordToHex(b) + wordToHex(c) + wordToHex(d);
	return temp.toLowerCase();
}


// --- From: core/src/parser/index.ts ---
import type { Kire } from "../kire";
import type { DirectiveDefinition, Node } from "../types";

export class Parser {
	private cursor = 0;
	private stack: Node[] = [];
	private rootChildren: Node[] = [];
	public line = 1;
	public column = 1;

	constructor(
		private template: string,
		private kire: Kire,
	) {}

	public parse(): Node[] {
		this.cursor = 0;
		this.stack = [];
		this.rootChildren = [];

		while (this.cursor < this.template.length) {
			const remaining = this.template.slice(this.cursor);
			//console.log('PARSER:', {
			//  cursor: this.cursor,
			//  remaining: remaining.slice(0, 30),
			//  stack: this.stack.map(s => s.name)
			//});

			// Check for interpolation {{ ... }}
			const interpolationMatch = remaining.match(/^\{\{([\s\S]*?)\}\}/);
			if (interpolationMatch) {
				this.addNode({
					type: "variable",
					content: interpolationMatch[1]?.trim(),
					start: this.cursor,
					end: this.cursor + interpolationMatch[0].length,
				});
				this.advance(interpolationMatch[0]);
				continue;
			}

			// Check for escaped directive @@
			if (remaining.startsWith("@@")) {
				this.addNode({
					type: "text",
					content: "@",
					start: this.cursor,
					end: this.cursor + 2,
				});
				this.advance("@@");
				continue;
			}

			// Check for directive @name(...) or @name without parentheses
			const directiveStartMatch = remaining.match(/^@(\w+)/);
			if (directiveStartMatch) {
				const [fullMatch, name] = directiveStartMatch;

				//console.log('FOUND DIRECTIVE:', { name, fullMatch, stack: this.stack.map(s => s.name) });

				// Check if it has arguments
				let argsStr: string | undefined;
				let argsEndIndex = fullMatch.length;

				// Verifica se tem parênteses APENAS se o próximo caractere for '('
				if (remaining[fullMatch.length] === "(") {
					// Parse arguments with balanced parentheses
					let depth = 1;
					let i = fullMatch.length + 1;
					let inQuote = false;
					let quoteChar = "";

					while (i < remaining.length && depth > 0) {
						const char = remaining[i];
						if (
							(char === '"' || char === "'") &&
							(i === 0 || remaining[i - 1] !== "\\")
						) {
							if (inQuote && char === quoteChar) {
								inQuote = false;
							} else if (!inQuote) {
								inQuote = true;
								quoteChar = char;
							}
						}

						if (!inQuote) {
							if (char === "(") depth++;
							else if (char === ")") depth--;
						}
						i++;
					}

					if (depth === 0) {
						argsStr = remaining.slice(fullMatch.length + 1, i - 1);
						argsEndIndex = i;
					}
				}

				if (name === "end") {
					//console.log('HANDLING END DIRECTIVE');
					this.handleEndDirective();
					this.advance(remaining.slice(0, argsEndIndex));
					continue;
				}

				const directiveDef = this.kire.getDirective(name as string);
				//console.log('DIRECTIVE DEF:', { name, directiveDef });

				// Check for sub-directive (parent logic)
				let isSubDirective = false;
				if (this.stack.length > 0) {
					const currentParent = this.stack[this.stack.length - 1];
					const parentDef = this.kire.getDirective(
						currentParent?.name as string,
					);

					//console.log('CHECKING SUB DIRECTIVE:', {
					//  parent: currentParent!.name,
					//  candidate: name,
					//  parentDef: parentDef
					//});

					if (parentDef?.parents) {
						const subDef = parentDef.parents.find((p) => p.name === name);
						//console.log('SUB DIRECTIVE RESULT:', { subDef });
						if (subDef) {
							//console.log('FOUND SUB DIRECTIVE! Processing:', name);
							this.handleSubDirective(
								name!,
								argsStr,
								remaining.slice(0, argsEndIndex),
								currentParent!,
								subDef,
							);
							this.advance(remaining.slice(0, argsEndIndex));
							isSubDirective = true;
							continue;
						}
					}
				}

				// If not a registered directive and not a sub-directive, treat as text
				if (!directiveDef && !isSubDirective) {
					//console.log('TREATING AS TEXT:', name);
					this.addNode({
						type: "text",
						content: fullMatch,
						start: this.cursor,
						end: this.cursor + fullMatch.length,
					});
					this.advance(fullMatch);
					continue;
				}

				const args = argsStr ? this.parseArgs(argsStr) : [];

				const node: Node = {
					type: "directive",
					name: name,
					args: args,
					start: this.cursor,
					end: this.cursor + argsEndIndex,
					children: [],
					related: [],
				};

				//console.log('ADDING DIRECTIVE NODE:', node);
				this.addNode(node);

				if (directiveDef?.children) {
					if (directiveDef.childrenRaw) {
						this.stack.push(node);

						const contentStart = this.cursor + argsEndIndex;
						const remainingTemplate = this.template.slice(contentStart);

						// Find closing @end with word boundary check
						const endMatch = remainingTemplate.match(/@end(?![a-zA-Z0-9_])/);

						if (endMatch) {
							const content = remainingTemplate.slice(0, endMatch.index);

							// Add text node
							this.addNode({
								type: "text",
								content: content,
								start: contentStart,
								end: contentStart + content.length,
							});

							this.stack.pop(); // Close immediately
							this.advance(
								remaining.slice(0, argsEndIndex) + content + endMatch[0],
							);
							continue;
						} else {
							// No end tag found, consume rest
							const content = remainingTemplate;
							this.addNode({
								type: "text",
								content: content,
								start: contentStart,
								end: this.template.length,
							});
							this.stack.pop();
							this.advance(remaining.slice(0, argsEndIndex) + content);
							continue;
						}
					}
					//console.log('PUSHING TO STACK:', name);
					this.stack.push(node);
				}

				this.advance(remaining.slice(0, argsEndIndex));
				continue;
			}

			// Text
			const nextInterpolation = remaining.indexOf("{{");
			const nextDirective = remaining.indexOf("@");

			let nextIndex = -1;
			if (nextInterpolation !== -1 && nextDirective !== -1) {
				nextIndex = Math.min(nextInterpolation, nextDirective);
			} else if (nextInterpolation !== -1) {
				nextIndex = nextInterpolation;
			} else if (nextDirective !== -1) {
				nextIndex = nextDirective;
			}

			if (nextIndex === -1) {
				this.addNode({
					type: "text",
					content: remaining,
					start: this.cursor,
					end: this.template.length,
				});
				this.advance(remaining);
			} else {
				if (nextIndex === 0) {
					this.addNode({
						type: "text",
						content: remaining[0],
						start: this.cursor,
						end: this.cursor + 1,
					});
					this.advance(remaining[0]!);
				} else {
					const text = remaining.slice(0, nextIndex);
					this.addNode({
						type: "text",
						content: text,
						start: this.cursor,
						end: this.cursor + text.length,
					});
					this.advance(text);
				}
			}
		}

		//console.log('FINAL RESULT:', JSON.stringify(this.rootChildren, null, 2));
		return this.rootChildren;
	}

	private handleEndDirective() {
		//console.log('HANDLE END - Stack before:', this.stack.map(s => s.name));
		if (this.stack.length > 0) {
			this.stack.pop();
		}
		//console.log('HANDLE END - Popped:', popped?.name);
		//console.log('HANDLE END - Stack after:', this.stack.map(s => s.name));
	}

	private handleSubDirective(
		name: string,
		argsStr: string | undefined,
		fullMatch: string,
		parentNode: Node,
		subDef: DirectiveDefinition,
	) {
		const args = argsStr ? this.parseArgs(argsStr) : [];

		const node: Node = {
			type: "directive",
			name: name,
			args: args,
			start: this.cursor,
			end: this.cursor + fullMatch.length,
			children: [],
			related: [],
		};

		//console.log('HANDLING SUB DIRECTIVE:', {
		//  name,
		//  parent: parentNode.name,
		//  node,
		//  parentRelated: parentNode.related
		//});

		if (!parentNode.related) parentNode.related = [];
		parentNode.related.push(node);

		if (subDef.children) {
			//console.log('PUSHING SUB DIRECTIVE TO STACK:', name);
			this.stack.push(node);
		}
	}

	private addNode(node: Node) {
		if (this.stack.length > 0) {
			const current = this.stack[this.stack.length - 1];
			if (current && !current.children) current.children = [];
			if (current?.children) {
				//console.log('ADDING TO CHILDREN of', current.name, ':', node.type, node.name || node.content);
				current.children.push(node);
			}
		} else {
			//console.log('ADDING TO ROOT:', node.type, node.name || node.content);
			this.rootChildren.push(node);
		}
	}

	private advance(str: string) {
		const lines = str.split("\n");
		if (lines.length > 1) {
			this.line += lines.length - 1;
			this.column = (lines[lines.length - 1]?.length || 0) + 1;
		} else {
			this.column += str.length;
		}
		this.cursor += str.length;
	}

	private parseArgs(argsStr: string): any[] {
		const args: any[] = [];
		let current = "";
		let inQuote = false;
		let quoteChar = "";
		let braceDepth = 0;
		let bracketDepth = 0;
		let parenDepth = 0;

		for (let i = 0; i < argsStr.length; i++) {
			const char = argsStr[i];

			// Handle quotes
			if (
				(char === '"' || char === "'") &&
				(i === 0 || argsStr[i - 1] !== "\\")
			) {
				if (inQuote && char === quoteChar) {
					inQuote = false;
				} else if (!inQuote) {
					inQuote = true;
					quoteChar = char;
				}
			}

			if (!inQuote) {
				if (char === "{") braceDepth++;
				else if (char === "}") braceDepth--;
				else if (char === "[") bracketDepth++;
				else if (char === "]") bracketDepth--;
				else if (char === "(") parenDepth++;
				else if (char === ")") parenDepth--;
			}

			if (
				char === "," &&
				!inQuote &&
				braceDepth === 0 &&
				bracketDepth === 0 &&
				parenDepth === 0
			) {
				args.push(current.trim());
				current = "";
			} else {
				current += char;
			}
		}
		if (current) args.push(current.trim());

		return args.map((arg) => {
			if (
				(arg.startsWith('"') && arg.endsWith('"')) ||
				(arg.startsWith("'") && arg.endsWith("'"))
			) {
				return arg.slice(1, -1);
			}
			if (arg === "true") return true;
			if (arg === "false") return false;
			if (!Number.isNaN(Number(arg))) return Number(arg);
			return arg;
		});
	}
}


